KIDS Distribution saved on Jul 10, 2017@09:40:43
Updated M-Unit functionality
**KIDS**:MASH*1.5*0^

**INSTALL NAME**
MASH*1.5*0
"BLD",9540,0)
MASH*1.5*0^MASH UTILITIES^0^3170710^n
"BLD",9540,1,0)
^^6^6^3170206^
"BLD",9540,1,1,0)
Updated release of MASH UTILITIES package for running unit tests on MUMPS
"BLD",9540,1,2,0)
code fixing a few issues.  Unit tests and coverage analysis may now be 
"BLD",9540,1,3,0)
run in accounts without VistA packages installed.  Cache systems with 
"BLD",9540,1,4,0)
computer names beginning with a digit will now be recognized as Cache 
"BLD",9540,1,5,0)
systems.  If the Break option is used, it now identifies the error or 
"BLD",9540,1,6,0)
type of failure that caused the break to happen.
"BLD",9540,4,0)
^9.64PA^17.9001^1
"BLD",9540,4,17.9001,0)
17.9001
"BLD",9540,4,17.9001,222)
y^y^f^^n^^y^m^n
"BLD",9540,4,"B",17.9001,17.9001)

"BLD",9540,6.3)
13
"BLD",9540,"INI")
ZZUTPRE
"BLD",9540,"INIT")
ZZUTPOST
"BLD",9540,"KRN",0)
^9.67PA^779.2^20
"BLD",9540,"KRN",.4,0)
.4
"BLD",9540,"KRN",.401,0)
.401
"BLD",9540,"KRN",.402,0)
.402
"BLD",9540,"KRN",.403,0)
.403
"BLD",9540,"KRN",.5,0)
.5
"BLD",9540,"KRN",.84,0)
.84
"BLD",9540,"KRN",3.6,0)
3.6
"BLD",9540,"KRN",3.8,0)
3.8
"BLD",9540,"KRN",9.2,0)
9.2
"BLD",9540,"KRN",9.8,0)
9.8
"BLD",9540,"KRN",9.8,"NM",0)
^9.68A^11^11
"BLD",9540,"KRN",9.8,"NM",1,0)
ut1^^0^B259333727
"BLD",9540,"KRN",9.8,"NM",2,0)
ut^^0^B259782146
"BLD",9540,"KRN",9.8,"NM",3,0)
utcover^^0^B86708312
"BLD",9540,"KRN",9.8,"NM",4,0)
utt1^^0^B47228039
"BLD",9540,"KRN",9.8,"NM",5,0)
utt2^^0^B685355
"BLD",9540,"KRN",9.8,"NM",6,0)
utt3^^0^B1628564
"BLD",9540,"KRN",9.8,"NM",7,0)
utt4^^0^B3071162
"BLD",9540,"KRN",9.8,"NM",8,0)
utt5^^0^B26349822
"BLD",9540,"KRN",9.8,"NM",9,0)
utt6^^0^B41667626
"BLD",9540,"KRN",9.8,"NM",10,0)
uttcovr^^0^B188096777
"BLD",9540,"KRN",9.8,"NM",11,0)
utt7^^0^B45754056
"BLD",9540,"KRN",9.8,"NM","B","ut",2)

"BLD",9540,"KRN",9.8,"NM","B","ut1",1)

"BLD",9540,"KRN",9.8,"NM","B","utcover",3)

"BLD",9540,"KRN",9.8,"NM","B","utt1",4)

"BLD",9540,"KRN",9.8,"NM","B","utt2",5)

"BLD",9540,"KRN",9.8,"NM","B","utt3",6)

"BLD",9540,"KRN",9.8,"NM","B","utt4",7)

"BLD",9540,"KRN",9.8,"NM","B","utt5",8)

"BLD",9540,"KRN",9.8,"NM","B","utt6",9)

"BLD",9540,"KRN",9.8,"NM","B","utt7",11)

"BLD",9540,"KRN",9.8,"NM","B","uttcovr",10)

"BLD",9540,"KRN",19,0)
19
"BLD",9540,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",9540,"KRN",19,"NM",1,0)
utMUNIT^^0
"BLD",9540,"KRN",19,"NM",2,0)
utMUNIT GROUP EDIT^^0
"BLD",9540,"KRN",19,"NM",3,0)
utMUNIT GROUP RUN^^0
"BLD",9540,"KRN",19,"NM","B","utMUNIT",1)

"BLD",9540,"KRN",19,"NM","B","utMUNIT GROUP EDIT",2)

"BLD",9540,"KRN",19,"NM","B","utMUNIT GROUP RUN",3)

"BLD",9540,"KRN",19.1,0)
19.1
"BLD",9540,"KRN",101,0)
101
"BLD",9540,"KRN",409.61,0)
409.61
"BLD",9540,"KRN",771,0)
771
"BLD",9540,"KRN",779.2,0)
779.2
"BLD",9540,"KRN",870,0)
870
"BLD",9540,"KRN",8989.51,0)
8989.51
"BLD",9540,"KRN",8989.52,0)
8989.52
"BLD",9540,"KRN",8994,0)
8994
"BLD",9540,"KRN",8994,"NM",0)
^9.68A^3^3
"BLD",9540,"KRN",8994,"NM",1,0)
utMUNIT-TEST GROUP LOAD^^0
"BLD",9540,"KRN",8994,"NM",2,0)
utMUNIT-TEST LOAD^^0
"BLD",9540,"KRN",8994,"NM",3,0)
utMUNIT-TEST NEXT^^0
"BLD",9540,"KRN",8994,"NM","B","utMUNIT-TEST GROUP LOAD",1)

"BLD",9540,"KRN",8994,"NM","B","utMUNIT-TEST LOAD",2)

"BLD",9540,"KRN",8994,"NM","B","utMUNIT-TEST NEXT",3)

"BLD",9540,"KRN","B",.4,.4)

"BLD",9540,"KRN","B",.401,.401)

"BLD",9540,"KRN","B",.402,.402)

"BLD",9540,"KRN","B",.403,.403)

"BLD",9540,"KRN","B",.5,.5)

"BLD",9540,"KRN","B",.84,.84)

"BLD",9540,"KRN","B",3.6,3.6)

"BLD",9540,"KRN","B",3.8,3.8)

"BLD",9540,"KRN","B",9.2,9.2)

"BLD",9540,"KRN","B",9.8,9.8)

"BLD",9540,"KRN","B",19,19)

"BLD",9540,"KRN","B",19.1,19.1)

"BLD",9540,"KRN","B",101,101)

"BLD",9540,"KRN","B",409.61,409.61)

"BLD",9540,"KRN","B",771,771)

"BLD",9540,"KRN","B",779.2,779.2)

"BLD",9540,"KRN","B",870,870)

"BLD",9540,"KRN","B",8989.51,8989.51)

"BLD",9540,"KRN","B",8989.52,8989.52)

"BLD",9540,"KRN","B",8994,8994)

"BLD",9540,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",9540,"QUES",0)
^9.62^^
"BLD",9540,"REQB",0)
^9.611^^
"DATA",17.9001,1,0)
TESTS FOR UNIT TEST ROUTINES
"DATA",17.9001,1,1,0)
^17.90011^7^7
"DATA",17.9001,1,1,1,0)
%utt1
"DATA",17.9001,1,1,2,0)
%utt2
"DATA",17.9001,1,1,3,0)
%utt3
"DATA",17.9001,1,1,4,0)
%utt4
"DATA",17.9001,1,1,5,0)
%utt5
"DATA",17.9001,1,1,6,0)
%utt6
"DATA",17.9001,1,1,7,0)
%uttcovr
"DATA",17.9001,1,2,0)
^17.90012^4^4^3170129^^
"DATA",17.9001,1,2,1,0)
This group will run all of the unit tests associated with the M-Unit
"DATA",17.9001,1,2,2,0)
code.  In addition, the routine %utt6 should be run as a regular routine
"DATA",17.9001,1,2,3,0)
from the top, and it will run all of the unit tests and,if on a G.TM
"DATA",17.9001,1,2,4,0)
system will run coverage analysis as well.
"FIA",17.9001)
M-UNIT TEST GROUP
"FIA",17.9001,0)
^%ut(17.9001,
"FIA",17.9001,0,0)
17.9001
"FIA",17.9001,0,1)
y^y^f^^n^^y^m^n
"FIA",17.9001,0,10)

"FIA",17.9001,0,11)

"FIA",17.9001,0,"RLRO")

"FIA",17.9001,0,"VR")
1.5^MASH
"FIA",17.9001,17.9001)
0
"FIA",17.9001,17.90011)
0
"FIA",17.9001,17.90012)
0
"INI")
ZZUTPRE
"INIT")
ZZUTPOST
"KRN",19,11538,-1)
0^1
"KRN",19,11538,0)
utMUNIT^M-Unit Tester^^B^^^^^^^^
"KRN",19,11538,1,0)
^^1^1^3140805^
"KRN",19,11538,1,1,0)
This is the context option for M-Unit Test functionality.
"KRN",19,11538,"RPC",0)
^19.05P^3^3
"KRN",19,11538,"RPC",1,0)
utMUNIT-TEST GROUP LOAD
"KRN",19,11538,"RPC",2,0)
utMUNIT-TEST LOAD
"KRN",19,11538,"RPC",3,0)
utMUNIT-TEST NEXT
"KRN",19,11538,"U")
M-UNIT TESTER
"KRN",19,11539,-1)
0^2
"KRN",19,11539,0)
utMUNIT GROUP EDIT^M-Unit Test Group Edit^^E^^^^^^^^TOOLKIT
"KRN",19,11539,1,0)
^19.06^6^6^3031030^^^
"KRN",19,11539,1,1,0)
This option can be used to maintain a listing of unit tests related to a 
"KRN",19,11539,1,2,0)
specific topic.  The Group identifies the topic, and the unit tests 
"KRN",19,11539,1,3,0)
related to that topic are added in the multiple.  Unit Tests can be run 
"KRN",19,11539,1,4,0)
by selecting a group, and all unit tests included in the multiple will be 
"KRN",19,11539,1,5,0)
used for the test.  In addition, any other references under the XTROU tag 
"KRN",19,11539,1,6,0)
in any of the included test routines will be included in the run.
"KRN",19,11539,30)
%ut(17.9001,
"KRN",19,11539,31)
AEMQL
"KRN",19,11539,50)
17.9001
"KRN",19,11539,51)
.01;1
"KRN",19,11539,"U")
M-UNIT TEST GROUP EDIT
"KRN",19,11540,-1)
0^3
"KRN",19,11540,0)
utMUNIT GROUP RUN^Run M-Unit Tests From Test Groups^^R^^^^^^^^TOOLKIT
"KRN",19,11540,1,0)
^^2^2^3031030^
"KRN",19,11540,1,1,0)
Provides a means of initiating a unit test run from the menu system based 
"KRN",19,11540,1,2,0)
on entries in the M-UNIT TEST GROUP file (#17.9001).
"KRN",19,11540,25)
PICKSET^%ut
"KRN",19,11540,"U")
RUN M-UNIT TESTS FROM TEST GRO
"KRN",8994,3261,-1)
0^1
"KRN",8994,3261,0)
utMUNIT-TEST GROUP LOAD^GUISET^%ut^4^^^^1
"KRN",8994,3262,-1)
0^2
"KRN",8994,3262,0)
utMUNIT-TEST LOAD^GUILOAD^%ut^4^^^^1
"KRN",8994,3263,-1)
0^3
"KRN",8994,3263,0)
utMUNIT-TEST NEXT^GUINEXT^%ut^4^^^^1
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",222,-1)
1^1
"PKG",222,0)
MASH UTILITIES^%u^Utilities associated with the M Advanced Shell
"PKG",222,20,0)
^9.402P^^
"PKG",222,22,0)
^9.49I^1^1
"PKG",222,22,1,0)
1.5
"PKG",222,22,1,"PAH",1,0)
0^3170710^2802
"PKG",222,22,1,"PAH",1,1,0)
^^6^6^3170710
"PKG",222,22,1,"PAH",1,1,1,0)
Updated release of MASH UTILITIES package for running unit tests on MUMPS
"PKG",222,22,1,"PAH",1,1,2,0)
code fixing a few issues.  Unit tests and coverage analysis may now be 
"PKG",222,22,1,"PAH",1,1,3,0)
run in accounts without VistA packages installed.  Cache systems with 
"PKG",222,22,1,"PAH",1,1,4,0)
computer names beginning with a digit will now be recognized as Cache 
"PKG",222,22,1,"PAH",1,1,5,0)
systems.  If the Break option is used, it now identifies the error or 
"PKG",222,22,1,"PAH",1,1,6,0)
type of failure that caused the break to happen.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
13
"RTN","ZZUTPOST")
0^^B21060915
"RTN","ZZUTPOST",1,0)
%utPOST ;VEN-SMH/JLI - post install for M-Unit Test software ;07/04/17  12:50
"RTN","ZZUTPOST",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","ZZUTPOST",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ZZUTPOST",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","ZZUTPOST",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","ZZUTPOST",6,0)
 ; Additions and Modifications made by Sam H. Habiel and Joel L. Ivey 02/2016-05/2017
"RTN","ZZUTPOST",7,0)
 ;
"RTN","ZZUTPOST",8,0)
 N X,I
"RTN","ZZUTPOST",9,0)
 D RENAME
"RTN","ZZUTPOST",10,0)
 QUIT
"RTN","ZZUTPOST",11,0)
 ;
"RTN","ZZUTPOST",12,0)
RENAME ;
"RTN","ZZUTPOST",13,0)
 N %S,%D ; Source, destination
"RTN","ZZUTPOST",14,0)
 S U="^"
"RTN","ZZUTPOST",15,0)
 S %S="ut^ut1^utcover^utt1^utt2^utt3^utt4^utt5^utt6^utt7^uttcovr"
"RTN","ZZUTPOST",16,0)
 S %D="%ut^%ut1^%utcover^%utt1^%utt2^%utt3^%utt4^%utt5^%utt6^%utt7^%uttcovr"
"RTN","ZZUTPOST",17,0)
 ;
"RTN","ZZUTPOST",18,0)
MOVE ; rename % routines
"RTN","ZZUTPOST",19,0)
 N %,X,Y,M
"RTN","ZZUTPOST",20,0)
 F %=1:1:$L(%D,"^") D  D MES(M) I +$SY=47 D MES(" ")
"RTN","ZZUTPOST",21,0)
 . S M="",X=$P(%S,U,%) ; from
"RTN","ZZUTPOST",22,0)
 . S Y=$P(%D,U,%) ; to
"RTN","ZZUTPOST",23,0)
 . Q:X=""
"RTN","ZZUTPOST",24,0)
 . S M="Routine: "_$J(X,8)
"RTN","ZZUTPOST",25,0)
 . Q:Y=""  I $T(^@X)=""  S M=M_"  Missing" Q
"RTN","ZZUTPOST",26,0)
 . S M=M_" Loaded, "
"RTN","ZZUTPOST",27,0)
 . D COPY(X,Y)
"RTN","ZZUTPOST",28,0)
 . S M=M_"Saved as "_$J(Y,8)
"RTN","ZZUTPOST",29,0)
 ;
"RTN","ZZUTPOST",30,0)
 QUIT  ; END
"RTN","ZZUTPOST",31,0)
 ;
"RTN","ZZUTPOST",32,0)
COPY(FROM,TO) ;
"RTN","ZZUTPOST",33,0)
 N XVAL,SYSTEM
"RTN","ZZUTPOST",34,0)
 S SYSTEM=$S($P($SY,",",2)'="":+$SY,1:0) ; protect against Windows with system names beginning with digits in Cache
"RTN","ZZUTPOST",35,0)
 I SYSTEM=0 S XVAL="ZL @FROM ZS @TO" X XVAL QUIT
"RTN","ZZUTPOST",36,0)
 I SYSTEM=47 DO  QUIT
"RTN","ZZUTPOST",37,0)
 . S FROM=$$PATH(FROM)
"RTN","ZZUTPOST",38,0)
 . S TO=$$PATH(TO,"WRITE")
"RTN","ZZUTPOST",39,0)
 . N CMD S CMD="cp "_FROM_" "_TO
"RTN","ZZUTPOST",40,0)
 . O "cp":(shell="/bin/sh":command=CMD:WRITEONLY)::"PIPE"
"RTN","ZZUTPOST",41,0)
 . U "cp" C "cp"
"RTN","ZZUTPOST",42,0)
 QUIT
"RTN","ZZUTPOST",43,0)
 ;
"RTN","ZZUTPOST",44,0)
PATH(ROUTINE,MODE) ; for GT.M return source file with path for a routine
"RTN","ZZUTPOST",45,0)
 ;input: ROUTINE=Name of routine
"RTN","ZZUTPOST",46,0)
 ;       MODE="READ" or "WRITE" defaults to READ
"RTN","ZZUTPOST",47,0)
 ;output: Full filename
"RTN","ZZUTPOST",48,0)
 ;
"RTN","ZZUTPOST",49,0)
 S MODE=$G(MODE,"READ") ;set MODE to default value
"RTN","ZZUTPOST",50,0)
 N FILE S FILE=$TR(ROUTINE,"%","_")_".m" ;convert rtn name to filename
"RTN","ZZUTPOST",51,0)
 N ZRO S ZRO=$ZRO
"RTN","ZZUTPOST",52,0)
 ;
"RTN","ZZUTPOST",53,0)
 ; Get source routine
"RTN","ZZUTPOST",54,0)
 N %ZR
"RTN","ZZUTPOST",55,0)
 I MODE="READ" D SILENT^%RSEL(ROUTINE,"SRC") Q %ZR(ROUTINE)_FILE
"RTN","ZZUTPOST",56,0)
 ;
"RTN","ZZUTPOST",57,0)
 ; We are writing. Parse directories and get 1st routine directory
"RTN","ZZUTPOST",58,0)
 N DIRS
"RTN","ZZUTPOST",59,0)
 D PARSEZRO(.DIRS,ZRO)
"RTN","ZZUTPOST",60,0)
 N PATH S PATH=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",61,0)
 ;
"RTN","ZZUTPOST",62,0)
 QUIT PATH_FILE ;end of PATH return directory and filename
"RTN","ZZUTPOST",63,0)
 ;
"RTN","ZZUTPOST",64,0)
 ;
"RTN","ZZUTPOST",65,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZZUTPOST",66,0)
 N PIECE
"RTN","ZZUTPOST",67,0)
 N I
"RTN","ZZUTPOST",68,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZZUTPOST",69,0)
 N CNT S CNT=1
"RTN","ZZUTPOST",70,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZZUTPOST",71,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZZUTPOST",72,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",73,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",74,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZZUTPOST",75,0)
 QUIT
"RTN","ZZUTPOST",76,0)
 ;
"RTN","ZZUTPOST",77,0)
ZRO1ST(DIRS) ; $$ Get first routine directory
"RTN","ZZUTPOST",78,0)
 N OUT ; $$ return
"RTN","ZZUTPOST",79,0)
 N %1 S %1=DIRS(1) ; 1st directory
"RTN","ZZUTPOST",80,0)
 ; Parse with (...)
"RTN","ZZUTPOST",81,0)
 I %1["(" DO
"RTN","ZZUTPOST",82,0)
 . S OUT=$P(%1,"(",2)
"RTN","ZZUTPOST",83,0)
 . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZZUTPOST",84,0)
 . E  S OUT=$P(OUT,")")
"RTN","ZZUTPOST",85,0)
 ; no parens
"RTN","ZZUTPOST",86,0)
 E  S OUT=%1
"RTN","ZZUTPOST",87,0)
 ;
"RTN","ZZUTPOST",88,0)
 ; Add trailing slash
"RTN","ZZUTPOST",89,0)
 I $E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZZUTPOST",90,0)
 QUIT OUT
"RTN","ZZUTPOST",91,0)
 ;
"RTN","ZZUTPOST",92,0)
MES(T,B) ;Write message.
"RTN","ZZUTPOST",93,0)
 S B=$G(B)
"RTN","ZZUTPOST",94,0)
 I $L($T(BMES^XPDUTL)) D BMES^XPDUTL(T):B,MES^XPDUTL(T):'B Q
"RTN","ZZUTPOST",95,0)
 W:B ! W !,T
"RTN","ZZUTPOST",96,0)
 Q
"RTN","ZZUTPOST",97,0)
 ;
"RTN","ZZUTPOST",98,0)
TEST ; @TEST - TESTING TESTING
"RTN","ZZUTPOST",99,0)
 ;
"RTN","ZZUTPOST",100,0)
 N FAIL S FAIL=0
"RTN","ZZUTPOST",101,0)
 N ZR S ZR="o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",102,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",103,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",104,0)
 I FIRSTDIR'="p/" W !,"TEST 1 Expected 'p/', got '"_FIRSTDIR_"'" S FAIL=FAIL+1 ;S $EC=",U1,"
"RTN","ZZUTPOST",105,0)
 ;
"RTN","ZZUTPOST",106,0)
 N ZR S ZR="/var/abc(/var/abc/r/) o(p r) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",107,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",108,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",109,0)
 I FIRSTDIR'="/var/abc/r/" W !,"TEST 2 Expected '/var/abc/r/', got '"_FIRSTDIR_"'" S FAIL=FAIL+1 ;S $EC=",U1,"
"RTN","ZZUTPOST",110,0)
 ;
"RTN","ZZUTPOST",111,0)
 N ZR S ZR="/abc/def /var/abc(/var/abc/r/) o(p r) $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",112,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",113,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",114,0)
 I FIRSTDIR'="/abc/def/" W !,"TEST 3 expected '/abc/def/', got '"_FIRSTDIR_"'" S FAIL=FAIL+1 ;S $EC=",U1,"
"RTN","ZZUTPOST",115,0)
 ;
"RTN","ZZUTPOST",116,0)
 I FAIL=0 WRITE "All tests have run successfully!",!
"RTN","ZZUTPOST",117,0)
 I FAIL>0 WRITE !,"***** Failed "_FAIL_" tests out of 3 *****",!
"RTN","ZZUTPOST",118,0)
 QUIT
"RTN","ZZUTPOST",119,0)
 ;
"RTN","ZZUTPOST",120,0)
PREKIDS ; Ready for KIDS - Move % routines to non-percent version
"RTN","ZZUTPOST",121,0)
 N %S,%D ; Source, destination
"RTN","ZZUTPOST",122,0)
 S U="^"
"RTN","ZZUTPOST",123,0)
 S %D="ut^ut1^utcover^utt1^utt2^utt3^utt4^utt5^utt6^utt7^uttcovr"
"RTN","ZZUTPOST",124,0)
 S %S="%ut^%ut1^%utcover^%utt1^%utt2^%utt3^%utt4^%utt5^%utt6^%utt7^%uttcovr"
"RTN","ZZUTPOST",125,0)
 D MOVE
"RTN","ZZUTPOST",126,0)
 QUIT
"RTN","ZZUTPOST",127,0)
 ;
"RTN","ZZUTPRE")
0^^B11731108
"RTN","ZZUTPRE",1,0)
%utPRE ;VEN/SMH/JLI - pre installation routine to set up MASH UTILITIES package and assign %ut routines and globals ;04/08/16  20:51
"RTN","ZZUTPRE",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","ZZUTPRE",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ZZUTPRE",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","ZZUTPRE",5,0)
 ; Modified by Sam H. Habiel and Joel L. Ivey 02/2016-04/2016
"RTN","ZZUTPRE",6,0)
 ;
"RTN","ZZUTPRE",7,0)
 ; The following is used to create, if it does not exist, the MASH UTILITIES
"RTN","ZZUTPRE",8,0)
 ; package, and to assign the %u namespace to this package.  This special
"RTN","ZZUTPRE",9,0)
 ; processing is necessary, since the input transform currently will not accept a
"RTN","ZZUTPRE",10,0)
 ; % or lower case character in the namespace.
"RTN","ZZUTPRE",11,0)
 ; JLI 160406 - following modified to update PACKAGE entry including current version and version subfile
"RTN","ZZUTPRE",12,0)
 N Y
"RTN","ZZUTPRE",13,0)
 S Y=+$O(^DIC(9.4,"B","MASH UTILITIES",""))
"RTN","ZZUTPRE",14,0)
 I 'Y N DIC,X S DIC="^DIC(9.4,",DIC(0)="",X="MASH UTILITIES",DIC("DR")="1////%u;2///Utilities associated with the M Advanced Shell" D FILE^DICN
"RTN","ZZUTPRE",15,0)
 I Y>0 D
"RTN","ZZUTPRE",16,0)
 . N YVAL S YVAL=+Y
"RTN","ZZUTPRE",17,0)
 . N VERSION S VERSION=$P($T(+2),";",3)
"RTN","ZZUTPRE",18,0)
 . N DIE,DA,DR S DIE="^DIC(9.4,",DA=+Y,DR="13///"_VERSION D ^DIE
"RTN","ZZUTPRE",19,0)
 . N DIC,X,DA S DA(1)=YVAL,DIC="^DIC(9.4,"_DA(1)_",22,",DIC(0)="",X=1.4,DIC("DR")="2///"_DT D FILE^DICN
"RTN","ZZUTPRE",20,0)
 . Q
"RTN","ZZUTPRE",21,0)
 ; end of modification
"RTN","ZZUTPRE",22,0)
 ; and if necessary, as in CACHE, map %ut routine and namespace in the current account.
"RTN","ZZUTPRE",23,0)
 I +$SY=0 D CACHEMAP ; This routine is CACHE specific
"RTN","ZZUTPRE",24,0)
 Q
"RTN","ZZUTPRE",25,0)
 ; The following code was provided by Sam Habiel to map %
"RTN","ZZUTPRE",26,0)
CACHEMAP ; Map %ut* Globals and Routines away from %SYS in Cache
"RTN","ZZUTPRE",27,0)
 ; ZEXCEPT: AddGlobalMapping,Class,Config,Configuration,Create,Get,GetErrorText,GetGlobalMapping,MapRoutines,MapGlobals,Namespaces,Status,class - these are all part of Cache class names
"RTN","ZZUTPRE",28,0)
 ; Get current namespace
"RTN","ZZUTPRE",29,0)
 N NMSP
"RTN","ZZUTPRE",30,0)
 I $P($P($ZV,") ",2),"(")<2012 S NMSP=$ZU(5)
"RTN","ZZUTPRE",31,0)
 I $P($P($ZV,") ",2),"(")>2011 S NMSP=$NAMESPACE
"RTN","ZZUTPRE",32,0)
 ;
"RTN","ZZUTPRE",33,0)
 N $ET S $ET="ZN NMSP D ^%ZTER S $EC="""""
"RTN","ZZUTPRE",34,0)
 ;
"RTN","ZZUTPRE",35,0)
 ZN "%SYS" ; Go to SYS
"RTN","ZZUTPRE",36,0)
 ;
"RTN","ZZUTPRE",37,0)
 ; Props
"RTN","ZZUTPRE",38,0)
 N PROP
"RTN","ZZUTPRE",39,0)
 N % S %=##Class(Config.Namespaces).Get(NMSP,.PROP) ; Get all namespace properties
"RTN","ZZUTPRE",40,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",41,0)
 ;
"RTN","ZZUTPRE",42,0)
 N DBG S DBG=PROP("Globals")  ; get the database globals location
"RTN","ZZUTPRE",43,0)
 N DBR S DBR=PROP("Routines") ; get the database routines location
"RTN","ZZUTPRE",44,0)
 ; the following is needed for the call to MapGlobals.Create below, is not set in above call
"RTN","ZZUTPRE",45,0)
 S PROP("Database")=NMSP
"RTN","ZZUTPRE",46,0)
 ;
"RTN","ZZUTPRE",47,0)
 ; Map %ut globals away from %SYS
"RTN","ZZUTPRE",48,0)
 N %
"RTN","ZZUTPRE",49,0)
 ; JLI 160406 - the following was modified to try the new method, and if it is not there
"RTN","ZZUTPRE",50,0)
 ;              (or another error), it then tries the method replacing the original one
"RTN","ZZUTPRE",51,0)
 ; try recommended replacement for deprecated method
"RTN","ZZUTPRE",52,0)
 TRY {  ; try new style
"RTN","ZZUTPRE",53,0)
   S %=##class(Config.Configuration).GetGlobalMapping(NMSP,"%ut*","",DBG,DBG)
"RTN","ZZUTPRE",54,0)
 }
"RTN","ZZUTPRE",55,0)
 CATCH {
"RTN","ZZUTPRE",56,0)
   S %=0
"RTN","ZZUTPRE",57,0)
 }
"RTN","ZZUTPRE",58,0)
 ; if it didn't work, use the deprecated method
"RTN","ZZUTPRE",59,0)
 I '% S %=##Class(Config.MapGlobals).Get(NMSP,"%ut*",.PROP) ; go back to original
"RTN","ZZUTPRE",60,0)
 ;
"RTN","ZZUTPRE",61,0)
 ; if not previously set, set new global mapping entry - try recommended replacement
"RTN","ZZUTPRE",62,0)
 ; for deprecated method for adding a global mapping
"RTN","ZZUTPRE",63,0)
 TRY { ; try new style to add global mapping
"RTN","ZZUTPRE",64,0)
   I '% S %=##class(Config.Configuration).AddGlobalMapping(NMSP,"%ut*","",DBG,DBG)
"RTN","ZZUTPRE",65,0)
 }
"RTN","ZZUTPRE",66,0)
 CATCH {
"RTN","ZZUTPRE",67,0)
   S %=0
"RTN","ZZUTPRE",68,0)
 }
"RTN","ZZUTPRE",69,0)
 ; again, if it didn't work use the original (now deprecated) method
"RTN","ZZUTPRE",70,0)
 S PROP("Database")=NMSP ; needed for call to MapGlobals.Create below
"RTN","ZZUTPRE",71,0)
 I '% S %=##Class(Config.MapGlobals).Create(NMSP,"%ut",.PROP) ; doesn't work with "%ut*"
"RTN","ZZUTPRE",72,0)
 ;
"RTN","ZZUTPRE",73,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",74,0)
 ; end of modification
"RTN","ZZUTPRE",75,0)
 ; Map %ut routines away from %SYS
"RTN","ZZUTPRE",76,0)
 N PROPRTN S PROPRTN("Database")=DBR
"RTN","ZZUTPRE",77,0)
 N %
"RTN","ZZUTPRE",78,0)
 S %=##Class(Config.MapRoutines).Get(NMSP,"%ut*",.PROPRTN)
"RTN","ZZUTPRE",79,0)
 S PROPRTN("Database")=DBR  ; Cache seems to like deleting this
"RTN","ZZUTPRE",80,0)
 I '% S %=##Class(Config.MapRoutines).Create(NMSP,"%ut*",.PROPRTN)
"RTN","ZZUTPRE",81,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",82,0)
 ZN NMSP ; Go back
"RTN","ZZUTPRE",83,0)
 QUIT
"RTN","ut")
0^2^B259782146
"RTN","ut",1,0)
%ut ;VEN-SMH/JLI - PRIMARY PROGRAM FOR M-UNIT TESTING ;04/26/17  21:08
"RTN","ut",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","ut",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ut",4,0)
 ; Original routine authored by Joel L. Ivey as XTMUNIT while working for U.S. Department of Veterans Affairs 2003-2012
"RTN","ut",5,0)
 ; Includes addition of %utVERB and %utBREAK arguments and code related to them as well as other substantial additions authored by Sam Habiel 07/2013-04/2014
"RTN","ut",6,0)
 ; Additions and modifications made by Sam H. Habiel and Joel L. Ivey 2013-02/2017 ;
"RTN","ut",7,0)
 ;
"RTN","ut",8,0)
 ; This routine and its companion, %ut1, provide the basic functionality for
"RTN","ut",9,0)
 ; running unit tests on parts of M programs either at the command line level
"RTN","ut",10,0)
 ; or via the M-Unit GUI application for windows operating systems.
"RTN","ut",11,0)
 ;
"RTN","ut",12,0)
 ; Original by Dr. Joel Ivey (JLI)
"RTN","ut",13,0)
 ; Contributions by Dr. Sam Habiel (SMH)
"RTN","ut",14,0)
 ;   older comments moved to %utcover due to space requirements
"RTN","ut",15,0)
 ;
"RTN","ut",16,0)
 ; For a list of changes in this version in this routine see tag %ut in routine %utt2
"RTN","ut",17,0)
 ;
"RTN","ut",18,0)
 D ^%utt6 ; runs unit tests on all of it
"RTN","ut",19,0)
 Q
"RTN","ut",20,0)
 ;
"RTN","ut",21,0)
EN(%utRNAM,%utVERB,%utBREAK) ; .SR Entry point with primary test routine name
"RTN","ut",22,0)
 ; %utRNAM: (Required) Routine name that contians the tags with @TEST in them or the tag XTROU
"RTN","ut",23,0)
 ; %utVERB: (optional) 1 for verbose output or for verbose and timing info 2 (milliseconds) or 3 (microseconds).
"RTN","ut",24,0)
 ; %utBREAK:(optional) bool - Break upon error or upon failure
"RTN","ut",25,0)
 N %utLIST,%utROU,%ut,%utIO
"RTN","ut",26,0)
 S %utLIST=1,%utROU(%utLIST)=%utRNAM,%utIO=$S($D(IO)#2:IO,1:$PRINCIPAL)
"RTN","ut",27,0)
 N IO S IO=%utIO
"RTN","ut",28,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",29,0)
 D SETUT
"RTN","ut",30,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",31,0)
 Q
"RTN","ut",32,0)
 ;
"RTN","ut",33,0)
GETSYS() ;.EF - returns numeric indicator of system value
"RTN","ut",34,0)
 N VALUE
"RTN","ut",35,0)
 ; Cache uses name of system, and has no second comma piece (unless it is part of system name), so set value to zero if no second comma piece is present in case system name begins with a number
"RTN","ut",36,0)
 S VALUE=$S($P($SY,",",2)'="":+$SY,1:0)
"RTN","ut",37,0)
 Q VALUE
"RTN","ut",38,0)
 ;
"RTN","ut",39,0)
SETUT ;
"RTN","ut",40,0)
 ; VEN/SMH 26JUL2013
"RTN","ut",41,0)
 I '($D(IO)#2) S IO=$PRINCIPLE
"RTN","ut",42,0)
 S U="^"
"RTN","ut",43,0)
 ; VEN/SMH 26JUL2013 END
"RTN","ut",44,0)
 ;
"RTN","ut",45,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",46,0)
 S %ut("IO")=IO
"RTN","ut",47,0)
 S %ut=1 ; set to identify unit test being run check with $$ISUTEST^%ut()
"RTN","ut",48,0)
 ;
"RTN","ut",49,0)
 ; ZEXCEPT: %utBREAK
"RTN","ut",50,0)
 I $G(%utBREAK) S %ut("BREAK")=1
"RTN","ut",51,0)
 Q
"RTN","ut",52,0)
 ;
"RTN","ut",53,0)
EN1(%utROU,%utLIST) ;
"RTN","ut",54,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT
"RTN","ut",55,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",56,0)
 ; ZEXCEPT: GetCPUTime,Process -- parts of Cache method names
"RTN","ut",57,0)
 ; ZEXCEPT: IOM - if present margin width defined by Kernel
"RTN","ut",58,0)
 N %utERRL,%utK,%utI,%utJ,%utSTRT,%utONLY,%utROU1
"RTN","ut",59,0)
 ; ZEXCEPT: %utVERB   -- ARGUMENT TO EN
"RTN","ut",60,0)
 I '+$G(%utVERB) S %utVERB=0
"RTN","ut",61,0)
 ;
"RTN","ut",62,0)
 ; Structure map for %ut
"RTN","ut",63,0)
 ; -- CURR = Counter for routine number. Used as sub in %utROU
"RTN","ut",64,0)
 ; -- ECNT = Entry point count in loop (cf. NERT); VEN/SMH - Needed?
"RTN","ut",65,0)
 ; -- FAIL = Number of failures
"RTN","ut",66,0)
 ; -- CHK  = Number of checks ran (TF/EQ/FAIL)
"RTN","ut",67,0)
 ; -- NENT = Number of entry points ran
"RTN","ut",68,0)
 ; -- ERRN = Number of errors
"RTN","ut",69,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",70,0)
 ;
"RTN","ut",71,0)
 ; -- GET LIST OF ROUTINES --
"RTN","ut",72,0)
 ; first get any tree of routines from this one
"RTN","ut",73,0)
 D GETTREE^%ut1(.%utROU,.%utLIST)
"RTN","ut",74,0)
 ; identify whether any tests are marked with !test - as run only these tests
"RTN","ut",75,0)
 S %utONLY=0
"RTN","ut",76,0)
 F I=1:1 S %utROU1=$G(%utROU(I)) Q:%utROU1=""  D CHEKTEST^%ut1(%utROU1,.%ut,.%utETRY,1) I %ut("ENTN")>0 S %utONLY=1 Q
"RTN","ut",77,0)
 ; Now process each routine that has been referenced
"RTN","ut",78,0)
 N CURRROU
"RTN","ut",79,0)
 S %ut("CURR")=0
"RTN","ut",80,0)
 F  S %ut("CURR")=%ut("CURR")+1 Q:'$D(%utROU(%ut("CURR")))  S CURRROU=%utROU(%ut("CURR")) D  I $T(@("SHUTDOWN^"_CURRROU))'="" D @("SHUTDOWN^"_CURRROU)
"RTN","ut",81,0)
 . I $T(@("STARTUP^"_CURRROU))'="" D @("STARTUP^"_CURRROU)
"RTN","ut",82,0)
 . N %utETRY ; Test list to run
"RTN","ut",83,0)
 . ;
"RTN","ut",84,0)
 . I %utVERB D  ; JLI 161113 - if verbose, list routine name as header for following tags
"RTN","ut",85,0)
 . . N LINEMARK,LENGTH
"RTN","ut",86,0)
 . . S LENGTH=$S(($L(CURRROU)#2):($L(CURRROU)+3),1:($L(CURRROU)+2))
"RTN","ut",87,0)
 . . N RM S RM=$G(IOM,80)-2 ; SMH
"RTN","ut",88,0)
 . . S $P(LINEMARK,"-",(RM-LENGTH)/2)="-"
"RTN","ut",89,0)
 . . W !!," ",LINEMARK," ",CURRROU," ",LINEMARK
"RTN","ut",90,0)
 . . Q
"RTN","ut",91,0)
 . ;
"RTN","ut",92,0)
 . ; Collect Test list.
"RTN","ut",93,0)
 . D CHEKTEST^%ut1(%utROU(%ut("CURR")),.%ut,.%utETRY,%utONLY)
"RTN","ut",94,0)
 . ;
"RTN","ut",95,0)
 . ; if a SETUP entry point exists, save it off in %ut
"RTN","ut",96,0)
 . S %ut("SETUP")=""
"RTN","ut",97,0)
 . N %utSETUP S %utSETUP="SETUP^"_%utROU(%ut("CURR"))
"RTN","ut",98,0)
 . S %ut("LINE")=$T(@%utSETUP) I %ut("LINE")'="" S %ut("SETUP")=%utSETUP
"RTN","ut",99,0)
 . K %utSETUP
"RTN","ut",100,0)
 . ;
"RTN","ut",101,0)
 . ; if a TEARDOWN entry point exists, ditto
"RTN","ut",102,0)
 . S %ut("TEARDOWN")=""
"RTN","ut",103,0)
 . N %utTEARDOWN S %utTEARDOWN="TEARDOWN^"_%utROU(%ut("CURR"))
"RTN","ut",104,0)
 . S %ut("LINE")=$T(@%utTEARDOWN) I %ut("LINE")'="" S %ut("TEARDOWN")=%utTEARDOWN
"RTN","ut",105,0)
 . K %utTEARDOWN
"RTN","ut",106,0)
 . ;
"RTN","ut",107,0)
 . ; == THIS FOR/DO BLOCK IS THE CENTRAL TEST RUNNER ==
"RTN","ut",108,0)
 . S %utI=0
"RTN","ut",109,0)
 . F  S %utI=$O(%utETRY(%utI)) Q:%utI'>0  S %ut("ENUM")=%ut("ERRN")+%ut("FAIL") D
"RTN","ut",110,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",111,0)
 . . ;
"RTN","ut",112,0)
 . . ; Run Set-up Code (only if present)
"RTN","ut",113,0)
 . . S %ut("ENT")=$G(%ut("SETUP")) ; Current entry
"RTN","ut",114,0)
 . . S %ut("NAME")="Set-up Code"
"RTN","ut",115,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",116,0)
 . . ;
"RTN","ut",117,0)
 . . ; Run actual test
"RTN","ut",118,0)
 . . S %ut("ECNT")=%ut("ECNT")+1
"RTN","ut",119,0)
 . . S %ut("NAME")=%utETRY(%utI,"NAME")
"RTN","ut",120,0)
 . . S %ut("ENT")=%utETRY(%utI)_"^"_%utROU(%ut("CURR"))
"RTN","ut",121,0)
 . . I %utVERB,'$D(%utGUI) D VERBOSE1(.%utETRY,%utI)
"RTN","ut",122,0)
 . . ;
"RTN","ut",123,0)
 . . I $$GETSYS()=47,%utVERB=3,'($$GTMVER()>6.2) S %utVERB=2 ; give ms instead of zeros if not supported
"RTN","ut",124,0)
 . . I %utVERB=2 N %utStart D  ; Time Start
"RTN","ut",125,0)
 . . . I $$GETSYS()=0  S %utStart=$P($SYSTEM.Process.GetCPUTime(),",")+$P($SYSTEM.Process.GetCPUTime(),",",2)
"RTN","ut",126,0)
 . . . I $$GETSYS()=47 S %utStart=$ZGETJPI("","CPUTIM")*10
"RTN","ut",127,0)
 . . ;
"RTN","ut",128,0)
 . . I %utVERB=3 N %utStart D  ; Time Start
"RTN","ut",129,0)
 . . . I $$GETSYS()=0 S %utStart=$P($NOW(),",",2)
"RTN","ut",130,0)
 . . . I $$GETSYS()=47 N V S V=$$GTMVER(0),%utStart=$s(V>6.2:$ZH,1:0)
"RTN","ut",131,0)
 . . ;
"RTN","ut",132,0)
 . . ; Run the test!
"RTN","ut",133,0)
 . . D @%ut("ENT")
"RTN","ut",134,0)
 . . ;
"RTN","ut",135,0)
 . . I %utVERB=2 N %utEnd,%utElapsed D  ; Time End
"RTN","ut",136,0)
 . . . I $$GETSYS()=0  S %utEnd=$P($SYSTEM.Process.GetCPUTime(),",")+$P($SYSTEM.Process.GetCPUTime(),",",2)
"RTN","ut",137,0)
 . . . I $$GETSYS()=47 S %utEnd=$ZGETJPI("","CPUTIM")*10
"RTN","ut",138,0)
 . . . S %utElapsed=%utEnd-%utStart_"ms"
"RTN","ut",139,0)
 . . ;
"RTN","ut",140,0)
 . . I %utVERB=3 N %utEnd,%utElapsed D  ; Time End
"RTN","ut",141,0)
 . . . I $$GETSYS()=0 S %utEnd=$P($NOW(),",",2) S %utElapsed=(%utEnd-%utStart)*1000,%utElapsed=%utElapsed_"ms"
"RTN","ut",142,0)
 . . . I $$GETSYS()=47 N V S V=$$GTMVER(0),%utEnd=$s(V>6.2:$ZH,1:0) S %utElapsed=$$ZHDIF(%utStart,%utEnd)
"RTN","ut",143,0)
 . . ;
"RTN","ut",144,0)
 . . ; Run Teardown Code (only if present)
"RTN","ut",145,0)
 . . S %ut("ENT")=$G(%ut("TEARDOWN"))
"RTN","ut",146,0)
 . . S %ut("NAME")="Teardown Code"
"RTN","ut",147,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",148,0)
 . . ;
"RTN","ut",149,0)
 . . ; ENUM = Number of errors + failures
"RTN","ut",150,0)
 . . ; Only print out the success message [OK] If our error number remains
"RTN","ut",151,0)
 . . ; the same as when we started the loop.
"RTN","ut",152,0)
 . . I %utVERB,'$D(%utGUI) D
"RTN","ut",153,0)
 . . . I %ut("ENUM")=(%ut("ERRN")+%ut("FAIL")) D VERBOSE(.%utETRY,1,%utVERB,$G(%utElapsed)) I 1
"RTN","ut",154,0)
 . . . E  D VERBOSE(.%utETRY,0,%utVERB,$G(%utElapsed))
"RTN","ut",155,0)
 . . . Q
"RTN","ut",156,0)
 . . Q
"RTN","ut",157,0)
 . ; keep a %utCNT of number of entry points executed across all routines
"RTN","ut",158,0)
 . S %ut("NENT")=%ut("NENT")+%ut("ENTN")
"RTN","ut",159,0)
 . Q
"RTN","ut",160,0)
 ;
"RTN","ut",161,0)
 ; -- SHUTDOWN --
"RTN","ut",162,0)
 D SETIO^%ut1
"RTN","ut",163,0)
 W !!,"Ran ",%utLIST," Routine",$S(%utLIST>1:"s",1:""),", ",%ut("NENT")," Entry Tag",$S(%ut("NENT")>1:"s",1:"")
"RTN","ut",164,0)
 W !,"Checked ",%ut("CHK")," test",$S(%ut("CHK")>1:"s",1:""),", with ",%ut("FAIL")," failure",$S(%ut("FAIL")'=1:"s",1:"")," and encountered ",%ut("ERRN")," error",$S(%ut("ERRN")'=1:"s",1:""),"."
"RTN","ut",165,0)
 S ^TMP("%ut",$J,"UTVALS")=%utLIST_U_%ut("NENT")_U_%ut("CHK")_U_%ut("FAIL")_U_%ut("ERRN") ; JLI 150621 so programs running several sets of unit tests can generate totals
"RTN","ut",166,0)
 D RESETIO^%ut1
"RTN","ut",167,0)
 Q
"RTN","ut",168,0)
 ; -- end EN1
"RTN","ut",169,0)
VERBOSE(%utETRY,SUCCESS,%utVERB,%utElapsed) ; Say whether we succeeded or failed.
"RTN","ut",170,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",171,0)
 ; ZEXCEPT: IOM - if present - margin width defined by Kernel
"RTN","ut",172,0)
 D SETIO^%ut1
"RTN","ut",173,0)
 N RM S RM=$G(IOM,80)-7 ; Right Margin
"RTN","ut",174,0)
 I 23[%utVERB,$G(%utElapsed)]"" S RM=RM-9
"RTN","ut",175,0)
 I $X>RM W !," "
"RTN","ut",176,0)
 N I F I=$X+3:1:RM W "-"
"RTN","ut",177,0)
 W ?RM
"RTN","ut",178,0)
 I $G(SUCCESS) W "[OK]"
"RTN","ut",179,0)
 E  W "[FAIL]"
"RTN","ut",180,0)
 ;I 23[%utVERB,$G(%utElapsed)]"" W " ",%utElapsed
"RTN","ut",181,0)
 I 23[%utVERB,$G(%utElapsed)]"" W " ",$J(%utElapsed,8,3),"ms"
"RTN","ut",182,0)
 D RESETIO^%ut1
"RTN","ut",183,0)
 Q
"RTN","ut",184,0)
 ;
"RTN","ut",185,0)
VERBOSE1(%utETRY,%utI) ; Print out the entry point info
"RTN","ut",186,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",187,0)
 D SETIO^%ut1
"RTN","ut",188,0)
 W !,%utETRY(%utI) I $G(%utETRY(%utI,"NAME"))'="" W " - ",%utETRY(%utI,"NAME")
"RTN","ut",189,0)
 D RESETIO^%ut1
"RTN","ut",190,0)
 Q
"RTN","ut",191,0)
 ;
"RTN","ut",192,0)
CHKTF(XTSTVAL,XTERMSG) ; Entry point for checking True or False values
"RTN","ut",193,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",194,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",195,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",196,0)
 I '$D(XTSTVAL) D NVLDARG^%ut1("CHKTF") Q
"RTN","ut",197,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",198,0)
 S %ut("CHK")=$G(%ut("CHK"))+1
"RTN","ut",199,0)
 I '$D(%utGUI) D
"RTN","ut",200,0)
 . D SETIO^%ut1
"RTN","ut",201,0)
 . I 'XTSTVAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " D
"RTN","ut",202,0)
 . . W XTERMSG,! S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",203,0)
 . . I $G(%ut("BREAK")) W !,"Breaking on False value"
"RTN","ut",204,0)
 . . I $G(%ut("BREAK")) BREAK  ; Break upon False value
"RTN","ut",205,0)
 . . Q
"RTN","ut",206,0)
 . I XTSTVAL W "."
"RTN","ut",207,0)
 . D RESETIO^%ut1
"RTN","ut",208,0)
 . Q
"RTN","ut",209,0)
 I $D(%utGUI),'XTSTVAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",210,0)
 Q
"RTN","ut",211,0)
 ;
"RTN","ut",212,0)
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG) ; Entry point for checking values to see if they are EQUAL
"RTN","ut",213,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut",214,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",215,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",216,0)
 N FAILMSG
"RTN","ut",217,0)
 I '$D(XTEXPECT)!'$D(XTACTUAL) D NVLDARG^%ut1("CHKEQ") Q
"RTN","ut",218,0)
 S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
"RTN","ut",219,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",220,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",221,0)
 I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
"RTN","ut",222,0)
 I '$D(%utGUI) D
"RTN","ut",223,0)
 . D SETIO^%ut1
"RTN","ut",224,0)
 . I XTEXPECT'=XTACTUAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W FAILMSG,XTERMSG,! D
"RTN","ut",225,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",226,0)
 . . I $D(%ut("BREAK")) W !,"Breaking on non-equal values"
"RTN","ut",227,0)
 . . I $D(%ut("BREAK")) BREAK  ; Break upon non-equal values
"RTN","ut",228,0)
 . . Q
"RTN","ut",229,0)
 . E  W "."
"RTN","ut",230,0)
 . D RESETIO^%ut1
"RTN","ut",231,0)
 . Q
"RTN","ut",232,0)
 I $D(%utGUI),XTEXPECT'=XTACTUAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_FAILMSG_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",233,0)
 Q
"RTN","ut",234,0)
 ;
"RTN","ut",235,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","ut",236,0)
 D FAIL^%ut1($G(XTERMSG))
"RTN","ut",237,0)
 Q
"RTN","ut",238,0)
 ;
"RTN","ut",239,0)
SUCCEED ; Entry point for forcing a success (Thx David Whitten)
"RTN","ut",240,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",241,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",242,0)
 ; Switch IO and write out the dot for activity
"RTN","ut",243,0)
 I '$D(%utGUI) D
"RTN","ut",244,0)
 . D SETIO^%ut1
"RTN","ut",245,0)
 . W "."
"RTN","ut",246,0)
 . D RESETIO^%ut1
"RTN","ut",247,0)
 ;
"RTN","ut",248,0)
 ; Increment test counter
"RTN","ut",249,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",250,0)
 QUIT
"RTN","ut",251,0)
 ;
"RTN","ut",252,0)
CHKLEAKS(%utCODE,%utLOC,%utINPT) ; functionality to check for variable leaks on executing a section of code
"RTN","ut",253,0)
 ; see CHKLEAKS^%utcover for description of arguments
"RTN","ut",254,0)
 D CHKLEAKS^%utcover(%utCODE,%utLOC,.%utINPT)
"RTN","ut",255,0)
 Q
"RTN","ut",256,0)
 ;
"RTN","ut",257,0)
ERROR ; record errors
"RTN","ut",258,0)
 ; ZEXCEPT: %utERRL,%utGUI,%utERR -CREATED IN SETUP, KILLED IN END
"RTN","ut",259,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",260,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",261,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",262,0)
 I '$D(%utGUI) D ERROR1
"RTN","ut",263,0)
 I $D(%utGUI) D
"RTN","ut",264,0)
 . S %ut("CNT")=%ut("CNT")+1
"RTN","ut",265,0)
 . S %utERR=%utERR+1
"RTN","ut",266,0)
 . S @%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"ERROR"_XTGUISEP_$S($$GETSYS()=47:$ZS,1:$ZE)
"RTN","ut",267,0)
 . Q
"RTN","ut",268,0)
 S @($S($$GETSYS()=47:"$ZS",1:"$ZE")_"="_""""""),$EC=""
"RTN","ut",269,0)
 Q
"RTN","ut",270,0)
 ;
"RTN","ut",271,0)
ERROR1 ;
"RTN","ut",272,0)
 ; ZEXCEPT: %utERRL -CREATED IN SETUP, KILLED IN END
"RTN","ut",273,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",274,0)
 I $G(%ut("BREAK")) W !,"Breaking on ERROR recorded: ",$S($$GETSYS()=47:$ZS,1:$ZE)
"RTN","ut",275,0)
 I $G(%ut("BREAK")) S @($S($$GETSYS()=47:"$ZS",1:"$ZE")_"="_""""""),$EC="" ; output for break added JLI 161020
"RTN","ut",276,0)
 I $G(%ut("BREAK")) BREAK  ; if we are asked to break upon error, please do so!
"RTN","ut",277,0)
 D SETIO^%ut1
"RTN","ut",278,0)
 W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - Error: " W $S($$GETSYS()=47:$ZS,1:$ZE),! D
"RTN","ut",279,0)
 . S %ut("ERRN")=%ut("ERRN")+1,%utERRL(%ut("ERRN"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=$S($$GETSYS()=47:$ZS,1:$ZE),%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",280,0)
 . Q
"RTN","ut",281,0)
 D RESETIO^%ut1
"RTN","ut",282,0)
 Q
"RTN","ut",283,0)
 ;
"RTN","ut",284,0)
ISUTEST() ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
"RTN","ut",285,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",286,0)
 Q $G(%ut)=1
"RTN","ut",287,0)
 ;
"RTN","ut",288,0)
PICKSET ; .OPT Interactive selection of MUnit Test Group
"RTN","ut",289,0)
 N DIC,Y,%utROU,%utLIST,DIR
"RTN","ut",290,0)
 I '$$ISUTEST^%ut() S DIC=17.9001,DIC(0)="AEQM" D ^DIC Q:Y'>0  W ! D GETSET(+Y,.%utROU,.%utLIST) N DIC,Y,%ut D SETUT D EN1(.%utROU,%utLIST) S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
"RTN","ut",291,0)
 Q
"RTN","ut",292,0)
 ;
"RTN","ut",293,0)
RUNSET(SETNAME,VERBOSE) ; .SR Run with Specified Selection of MUnit Test Group
"RTN","ut",294,0)
 N Y,%utROU,%utLIST,%utVERB
"RTN","ut",295,0)
 Q:$G(SETNAME)=""
"RTN","ut",296,0)
 S %utVERB=$G(VERBOSE,0)
"RTN","ut",297,0)
 S Y=+$$FIND1^DIC(17.9001,"","X",SETNAME) Q:Y'>0
"RTN","ut",298,0)
 D GETSET(Y,.%utROU,.%utLIST)
"RTN","ut",299,0)
 N Y,SETNAME,%ut
"RTN","ut",300,0)
 D SETUT
"RTN","ut",301,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",302,0)
 Q
"RTN","ut",303,0)
 ;
"RTN","ut",304,0)
 ; DOSET CAN BE USED TO RUN A SET OF TESTS BASED ON THE IEN IN THE MUNIT TEST GROUP file (#17.9001)
"RTN","ut",305,0)
DOSET(IEN,%utVERB) ; 140731 JLI added %utVERB as a second argument
"RTN","ut",306,0)
 ; IEN - Internal entry number for selected set of tests in the MUNIT TEST GROUP file (#17.9001)
"RTN","ut",307,0)
 ; %utVERB - optional input that indicates verbose output is permitted
"RTN","ut",308,0)
 ;
"RTN","ut",309,0)
 N %utROU,%utLIST
"RTN","ut",310,0)
 I '$D(%utVERB) S %utVERB=0
"RTN","ut",311,0)
 S %utLIST=0
"RTN","ut",312,0)
 D GETSET($G(IEN),.%utROU,.%utLIST)
"RTN","ut",313,0)
 I %utLIST>0  N IEN,%ut D SETUT,EN1(.%utROU,%utLIST)
"RTN","ut",314,0)
 Q
"RTN","ut",315,0)
 ;
"RTN","ut",316,0)
GETSET(IEN,%utROU,%utLIST) ;  JLI 140731 - called from PICKSET, RUNSET, DOSET, GUISET
"RTN","ut",317,0)
 N IENS,%utROOT
"RTN","ut",318,0)
 ;I $T(+1^DIQ)="" QUIT  ; not in a VA KERNEL or VA FILEMAN environment
"RTN","ut",319,0)
 S IENS=IEN_"," D GETS^DIQ(17.9001,IENS,"1*","","%utROOT")
"RTN","ut",320,0)
 S %utLIST=0,IENS="" F  S IENS=$O(%utROOT(17.90011,IENS)) Q:IENS=""  S %utLIST=%utLIST+1,%utROU(%utLIST)=%utROOT(17.90011,IENS,.01)
"RTN","ut",321,0)
 Q
"RTN","ut",322,0)
 ;
"RTN","ut",323,0)
COV(NMSP,COVCODE,VERBOSITY) ; simply make it callable from %ut1 as well (along with other APIs) JLI 150101
"RTN","ut",324,0)
 D COV^%ut1(.NMSP,COVCODE,+$G(VERBOSITY)) ; see COV^%ut1 for description of arguments
"RTN","ut",325,0)
 Q
"RTN","ut",326,0)
 ;
"RTN","ut",327,0)
MULTAPIS(TESTROUS) ; .SR - RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","ut",328,0)
 ; input - TESTROUS - passed by reference
"RTN","ut",329,0)
 ; see TESTONLY in routine %utcover for full description of TESTROUS argument
"RTN","ut",330,0)
 D MULTAPIS^%utcover(.TESTROUS) ; RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","ut",331,0)
 Q
"RTN","ut",332,0)
 ;
"RTN","ut",333,0)
COVERAGE(ROUNMSP,TESTROUS,XCLDROUS,RESLTLVL)    ;.SR - run coverage analysis for multiple routines and entry points
"RTN","ut",334,0)
 ; input ROUNMSP - may be passed by reference
"RTN","ut",335,0)
 ; input TESTROUS - passed by reference
"RTN","ut",336,0)
 ; input XCLDROUS - passed by reference
"RTN","ut",337,0)
 ; input RESLTLVL
"RTN","ut",338,0)
 ; see COVERAGE in routine %utcover for full description of arguments
"RTN","ut",339,0)
 D COVERAGE^%utcover(.ROUNMSP,.TESTROUS,.XCLDROUS,+$G(RESLTLVL))
"RTN","ut",340,0)
 Q
"RTN","ut",341,0)
 ;
"RTN","ut",342,0)
GETUTVAL(UTDATA) ; .SR - returns totals for current unit test data in cumulative totals
"RTN","ut",343,0)
 ; usage   D GETUTVAL^%ut(.UTDATA)
"RTN","ut",344,0)
 ; input - UTDATA - passed by reference
"RTN","ut",345,0)
 ;
"RTN","ut",346,0)
 ; subscripted values returned:
"RTN","ut",347,0)
 ;   1) cumulative number of routines run;  2) cumulative number of entry tags;
"RTN","ut",348,0)
 ;   3) cumulative number of tests;         4) cummulative number of failures;
"RTN","ut",349,0)
 ;   5) cumulative number of errors
"RTN","ut",350,0)
 N VALS,I,VAL
"RTN","ut",351,0)
 S VALS=$G(^TMP("%ut",$J,"UTVALS")) I VALS="" Q
"RTN","ut",352,0)
 F I=1:1 S VAL=$P(VALS,U,I) Q:VAL=""  S UTDATA(I)=$G(UTDATA(I))+VAL
"RTN","ut",353,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",354,0)
 Q
"RTN","ut",355,0)
 ;
"RTN","ut",356,0)
LSTUTVAL(UTDATA) ; .SR - lists cumulative totals in UTDATA array
"RTN","ut",357,0)
 ; usage   D LSTUTVAL^%ut(.UTDATA)
"RTN","ut",358,0)
 ; input - UTDATA - passed by reference
"RTN","ut",359,0)
 W !!!,"------------ SUMMARY ------------"
"RTN","ut",360,0)
 W !,"Ran ",UTDATA(1)," Routine",$S(UTDATA(1)>1:"s",1:""),", ",UTDATA(2)," Entry Tag",$S(UTDATA(2)>1:"s",1:"")
"RTN","ut",361,0)
 W !,"Checked ",UTDATA(3)," test",$S(UTDATA(3)>1:"s",1:""),", with ",UTDATA(4)," failure",$S(UTDATA(4)'=1:"s",1:"")," and encountered ",UTDATA(5)," error",$S(UTDATA(5)'=1:"s",1:""),"."
"RTN","ut",362,0)
 Q
"RTN","ut",363,0)
 ;
"RTN","ut",364,0)
 ;
"RTN","ut",365,0)
GUISET(%utRSLT,XTSET) ; Entry point for GUI start with selected Test Set IEN - called by %ut-TEST GROUP LOAD rpc
"RTN","ut",366,0)
 N %utROU,%utLIST,%ut
"RTN","ut",367,0)
 D SETUT
"RTN","ut",368,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",369,0)
 D GETSET(XTSET,.%utROU,.%utLIST)
"RTN","ut",370,0)
 D GETLIST(.%utROU,%utLIST,%ut("RSLT"))
"RTN","ut",371,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","ut",372,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",373,0)
 Q
"RTN","ut",374,0)
 ;
"RTN","ut",375,0)
GUILOAD(%utRSLT,%utROUN) ; Entry point for GUI start with %utROUN containing primary routine name - called by %ut-TEST LOAD rpc
"RTN","ut",376,0)
 N %utROU,%ut
"RTN","ut",377,0)
 D SETUT
"RTN","ut",378,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",379,0)
 S %utROU(1)=%utROUN
"RTN","ut",380,0)
 D GETLIST(.%utROU,1,%ut("RSLT"))
"RTN","ut",381,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1"
"RTN","ut",382,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",383,0)
 Q
"RTN","ut",384,0)
 ;
"RTN","ut",385,0)
GETLIST(%utROU,%utLIST,%utRSLT) ; called from GUISET, GUILOAD
"RTN","ut",386,0)
 N I,%utROUL,%utROUN,%ut,XTCOMNT,XTVALUE,%utCNT
"RTN","ut",387,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
"RTN","ut",388,0)
 S %utCNT=0,XTCOMNT=""
"RTN","ut",389,0)
 D GETTREE^%ut1(.%utROU,%utLIST)
"RTN","ut",390,0)
 F I=1:1 Q:'$D(%utROU(I))  S %utROUL(%utROU(I))=""
"RTN","ut",391,0)
 S %utROUN="" F  S %utROUN=$O(%utROUL(%utROUN)) Q:%utROUN=""  D LOAD(%utROUN,.%utCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",392,0)
 M @%utRSLT=@XTVALUE
"RTN","ut",393,0)
 K @%utRSLT@("SHUTDOWN")
"RTN","ut",394,0)
 K @%utRSLT@("STARTUP")
"RTN","ut",395,0)
 S @XTVALUE@("LASTROU")=""
"RTN","ut",396,0)
 Q
"RTN","ut",397,0)
 ;
"RTN","ut",398,0)
 ; generate list of unit test routines, entry points and comments on test for entry point
"RTN","ut",399,0)
LOAD(%utROUN,%utNCNT,XTVALUE,XTCOMNT,%utROUL) ; called from GETLIST, and recursively from LOAD
"RTN","ut",400,0)
 I $T(@("^"_%utROUN))="" S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
"RTN","ut",401,0)
 S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_U_XTCOMNT
"RTN","ut",402,0)
 N %utI,XTX1,XTX2,LINE,LIST,I
"RTN","ut",403,0)
 I $T(@("STARTUP^"_%utROUN))'="",'$D(@XTVALUE@("STARTUP")) S @XTVALUE@("STARTUP")="STARTUP^"_%utROUN
"RTN","ut",404,0)
 I $T(@("SHUTDOWN^"_%utROUN))'="",'$D(@XTVALUE@("SHUTDOWN")) S @XTVALUE@("SHUTDOWN")="SHUTDOWN^"_%utROUN
"RTN","ut",405,0)
 D NEWSTYLE^%ut1(.LIST,%utROUN)
"RTN","ut",406,0)
 F I=1:1:LIST S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_LIST(I)
"RTN","ut",407,0)
 F %utI=1:1 S LINE=$T(@("XTENT+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),%utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_XTX1_U_XTX2
"RTN","ut",408,0)
 F %utI=1:1 S LINE=$T(@("XTROU+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(%utROUL(XTX1)) S %utROUL(XTX1)="" D LOAD(XTX1,.%utNCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",409,0)
 Q
"RTN","ut",410,0)
 ;
"RTN","ut",411,0)
GUINEXT(%utRSLT,%utLOC,XTGUISEP) ; Entry point for GUI execute next test - called by %ut-TEST NEXT rpc
"RTN","ut",412,0)
 ; XTGUISEP - added 110719 to provide for changing separator for GUI
"RTN","ut",413,0)
 ;            return from ^ to another value ~~^~~  so that data returned
"RTN","ut",414,0)
 ;            is not affected by ^ values in the data - if not present
"RTN","ut",415,0)
 ;            sets value to default ^
"RTN","ut",416,0)
 N %utETRY,%utROUT,XTOLROU,XTVALUE,%utERR,%utGUI
"RTN","ut",417,0)
 N %ut
"RTN","ut",418,0)
 I $G(XTGUISEP)="" S XTGUISEP="^"
"RTN","ut",419,0)
 D SETUT
"RTN","ut",420,0)
 S %ut("LOC")=%utLOC
"RTN","ut",421,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",422,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
"RTN","ut",423,0)
 S %ut("RSLT")=$NA(^TMP("GUINEXT",$J)) K @%ut("RSLT")
"RTN","ut",424,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",425,0)
 S %utETRY=$P(%utLOC,U),%utROUT=$P(%utLOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
"RTN","ut",426,0)
 S %utGUI=1
"RTN","ut",427,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",428,0)
 D  I %utROUT="" S @%utRSLT@(1)="" Q  ; 141018 JLI - Have to leave XTVALUE intact, in case they simply run again for STARTUP, etc.
"RTN","ut",429,0)
 . I XTOLROU="",$D(@XTVALUE@("STARTUP")) D
"RTN","ut",430,0)
 . . S %ut("LOC")=@XTVALUE@("STARTUP")
"RTN","ut",431,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",432,0)
 . . D @(@XTVALUE@("STARTUP"))
"RTN","ut",433,0)
 . . Q
"RTN","ut",434,0)
 . S @XTVALUE@("LASTROU")=%utROUT I %utROUT'="",$T(@("SETUP^"_%utROUT))'="" D
"RTN","ut",435,0)
 . . S %ut("LOC")="SETUP^"_%utROUT
"RTN","ut",436,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",437,0)
 . . D @("SETUP^"_%utROUT)
"RTN","ut",438,0)
 . . Q
"RTN","ut",439,0)
 . I %utROUT="",$D(@XTVALUE@("SHUTDOWN")) D
"RTN","ut",440,0)
 . . S %ut("LOC")=@XTVALUE@("SHUTDOWN")
"RTN","ut",441,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",442,0)
 . . D @(@XTVALUE@("SHUTDOWN"))
"RTN","ut",443,0)
 . . Q
"RTN","ut",444,0)
 . Q
"RTN","ut",445,0)
 S %ut("LOC")=%utLOC
"RTN","ut",446,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",447,0)
 D  ; to limit range of error trap so we continue through other tests
"RTN","ut",448,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",449,0)
 . D @%ut("LOC")
"RTN","ut",450,0)
 . Q
"RTN","ut",451,0)
 I $T(@("TEARDOWN^"_%utROUT))'="" D
"RTN","ut",452,0)
 . S %ut("LOC")="TEARDOWN^"_%utROUT
"RTN","ut",453,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",454,0)
 . D @("TEARDOWN^"_%utROUT)
"RTN","ut",455,0)
 . Q
"RTN","ut",456,0)
 S @%ut("RSLT")@(1)=%ut("CHK")_XTGUISEP_(%ut("CNT")-1-%utERR)_XTGUISEP_%utERR
"RTN","ut",457,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",458,0)
 Q
"RTN","ut",459,0)
 ;
"RTN","ut",460,0)
GTMVER(X) ;return OS version, X=1 - return OS
"RTN","ut",461,0)
 Q $S($G(X):$P($ZV," ",3,99),1:$P($P($ZV," V",2)," "))
"RTN","ut",462,0)
 ;
"RTN","ut",463,0)
ZHDIF(%ZH0,%ZH1) ;Display dif of two $ZH's
"RTN","ut",464,0)
 N SC0 S SC0=$P(%ZH0,",",2)
"RTN","ut",465,0)
 N SC1 S SC1=$P(%ZH1,",",2)
"RTN","ut",466,0)
 N DC0 S DC0=$P(%ZH0,",")*86400
"RTN","ut",467,0)
 N DC1 S DC1=$P(%ZH1,",")*86400
"RTN","ut",468,0)
 N MCS0 S MCS0=$P(%ZH0,",",3)/1000000
"RTN","ut",469,0)
 N MCS1 S MCS1=$P(%ZH1,",",3)/1000000
"RTN","ut",470,0)
 ;
"RTN","ut",471,0)
 N T0 S T0=SC0+DC0+MCS0
"RTN","ut",472,0)
 N T1 S T1=SC1+DC1+MCS1
"RTN","ut",473,0)
 ;
"RTN","ut",474,0)
 N %ZH2 S %ZH2=T1-T0*1000
"RTN","ut",475,0)
 QUIT %ZH2
"RTN","ut1")
0^1^B259333727
"RTN","ut1",1,0)
%ut1 ;VEN/SMH/JLI - CONTINUATION OF M-UNIT PROCESSING ;04/26/17  21:10
"RTN","ut1",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","ut1",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ut1",4,0)
 ; Original routine authored by Joel L. Ivey as XTMUNIT1 while working for U.S. Department of Veterans Affairs 2003-2012
"RTN","ut1",5,0)
 ; Includes addition of original COV entry and code related coverage analysis as well as other substantial additions authored by Sam Habiel 07/2013?04/2014
"RTN","ut1",6,0)
 ; Original by Dr. Joel Ivey
"RTN","ut1",7,0)
 ; Major contributions by Dr. Sam Habiel
"RTN","ut1",8,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-12/2015
"RTN","ut1",9,0)
 ; Additions and modifications made by Sam H. Habiel and Joel L. Ivey 12/2015-02/2017
"RTN","ut1",10,0)
 ;
"RTN","ut1",11,0)
 ; older comments moved to %utcover due to space requirements
"RTN","ut1",12,0)
 ;
"RTN","ut1",13,0)
 ; For a list of changes in this version in this routine see tag %ut1 in routine %utt2
"RTN","ut1",14,0)
 ;
"RTN","ut1",15,0)
 D ^%utt6 ; runs unit tests from several perspectives
"RTN","ut1",16,0)
 Q
"RTN","ut1",17,0)
 ;
"RTN","ut1",18,0)
 ;following is original header from XTMUNIT1 in unreleased patch XT*7.3*81 VA code
"RTN","ut1",19,0)
 ;XTMUNIT1    ;JLI/FO-OAK-CONTINUATION OF UNIT TEST ROUTINE ;2014-04-17  5:26 PM
"RTN","ut1",20,0)
 ;;7.3;TOOLKIT;**81**;APR 25 1995;Build 24
"RTN","ut1",21,0)
 ;
"RTN","ut1",22,0)
CHEKTEST(%utROU,%ut,%utUETRY,FLAG) ; Collect Test list.
"RTN","ut1",23,0)
 ; %utROU - input - Name of routine to check for tags with @TEST attribute
"RTN","ut1",24,0)
 ; %ut - input/output - passed by reference
"RTN","ut1",25,0)
 ; %utUETRY - input/output - passed by reference
"RTN","ut1",26,0)
 ; FLAG - optional - if present and true, select only !TEST entries to run
"RTN","ut1",27,0)
 ;
"RTN","ut1",28,0)
 ; Test list collected in two ways:
"RTN","ut1",29,0)
 ; - @TEST on labellines
"RTN","ut1",30,0)
 ; - Offsets of XTENT
"RTN","ut1",31,0)
 ;
"RTN","ut1",32,0)
 S %ut("ENTN")=0 ; Number of test, sub to %utUETRY.
"RTN","ut1",33,0)
 ;
"RTN","ut1",34,0)
 ; This stanza and everything below is for collecting @TEST.
"RTN","ut1",35,0)
 N I,LIST
"RTN","ut1",36,0)
 S FLAG=$G(FLAG,0)
"RTN","ut1",37,0)
 S I=$L($T(@(U_%utROU))) I I<0 Q "-1^Invalid Routine Name"
"RTN","ut1",38,0)
 D NEWSTYLE(.LIST,%utROU)
"RTN","ut1",39,0)
 I FLAG D
"RTN","ut1",40,0)
 . F I=1:1:LIST Q:'$D(LIST(I))  Q:LIST'>0  I $P(LIST(I),U)'="!" S LIST=LIST-1,I=I-1 F J=I+1:1:LIST S LIST(J)=LIST(J+1) I J=LIST K LIST(J+1)
"RTN","ut1",41,0)
 . F I=LIST+1:1 Q:'$D(LIST(I))  K LIST(I)
"RTN","ut1",42,0)
 . Q
"RTN","ut1",43,0)
 F I=1:1:LIST S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(LIST(I),U,2),%utUETRY(%ut("ENTN"),"NAME")=$P(LIST(I),U,3,99)
"RTN","ut1",44,0)
 ;
"RTN","ut1",45,0)
 I FLAG Q  ; don't check if only !TEST entries are selected
"RTN","ut1",46,0)
 ; This Stanza is to collect XTENT offsets
"RTN","ut1",47,0)
 N %utUI F %utUI=1:1 S %ut("ELIN")=$T(@("XTENT+"_%utUI_"^"_%utROU)) Q:$P(%ut("ELIN"),";",3)=""  D
"RTN","ut1",48,0)
 . N TAGNAME,FOUND S FOUND=0,TAGNAME=$P(%ut("ELIN"),";",3)
"RTN","ut1",49,0)
 . F I=1:1:%ut("ENTN") I %utUETRY(I)=TAGNAME S FOUND=1 Q  ; skip if already under NEW STYLE as well
"RTN","ut1",50,0)
 . I 'FOUND S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(%ut("ELIN"),";",3),%utUETRY(%ut("ENTN"),"NAME")=$P(%ut("ELIN"),";",4)
"RTN","ut1",51,0)
 . Q
"RTN","ut1",52,0)
 ;
"RTN","ut1",53,0)
 QUIT
"RTN","ut1",54,0)
 ;
"RTN","ut1",55,0)
GETTREE(%utROU,%utULIST) ;
"RTN","ut1",56,0)
 ; first get any other routines this one references for running subsequently
"RTN","ut1",57,0)
 ; then any that they refer to as well
"RTN","ut1",58,0)
 ; this builds a tree of all routines referred to by any routine including each only once
"RTN","ut1",59,0)
 N %utUK,%utUI,%utUJ,%utURNAM,%utURLIN
"RTN","ut1",60,0)
 F %utUK=1:1 Q:'$D(%utROU(%utUK))  D
"RTN","ut1",61,0)
 . F %utUI=1:1 S %utURLIN=$T(@("XTROU+"_%utUI_"^"_%utROU(%utUK))) S %utURNAM=$P(%utURLIN,";",3) Q:%utURNAM=""  D
"RTN","ut1",62,0)
 . . F %utUJ=1:1:%utULIST I %utROU(%utUJ)=%utURNAM S %utURNAM="" Q
"RTN","ut1",63,0)
 . . I %utURNAM'="",$T(@("+1^"_%utURNAM))="" W:'$D(XWBOS) "Referenced routine ",%utURNAM," not found.",! Q
"RTN","ut1",64,0)
 . . S:%utURNAM'="" %utULIST=%utULIST+1,%utROU(%utULIST)=%utURNAM
"RTN","ut1",65,0)
 QUIT
"RTN","ut1",66,0)
 ;
"RTN","ut1",67,0)
NEWSTYLE(LIST,ROUNAME) ; JLI 140726 identify and return list of newstyle tags or entries for this routine
"RTN","ut1",68,0)
 ; LIST - input, passed by reference - returns containing array with list of tags identified as tests
"RTN","ut1",69,0)
 ;                   LIST indicates number of tags identified, LIST(n)=tag^test_info where tag is entry point for test
"RTN","ut1",70,0)
 ; ROUNAME - input - routine name in which tests should be identified
"RTN","ut1",71,0)
 ;
"RTN","ut1",72,0)
 N I,VALUE,LINE
"RTN","ut1",73,0)
 K LIST S LIST=0
"RTN","ut1",74,0)
 ; search routine by line for a tag and @TEST declaration
"RTN","ut1",75,0)
 F I=1:1 S LINE=$T(@("+"_I_"^"_ROUNAME)) Q:LINE=""  S VALUE=$$CHECKTAG(LINE) I VALUE'="" S LIST=LIST+1,LIST(LIST)=VALUE
"RTN","ut1",76,0)
 Q
"RTN","ut1",77,0)
 ;
"RTN","ut1",78,0)
CHECKTAG(LINE) ; JLI 170426 modified to add !TEST to checks check line to determine @test TAG
"RTN","ut1",79,0)
 ; LINE - input - Line of code to be checked
"RTN","ut1",80,0)
 ; returns null line if not @TEST line or !TEST line, otherwise TAG^NOTE
"RTN","ut1",81,0)
 N TAG
"RTN","ut1",82,0)
 S TAG=$$CHKTAGS(LINE,"@TEST") I TAG'="" Q "@"_U_TAG
"RTN","ut1",83,0)
 S TAG=$$CHKTAGS(LINE,"!TEST")
"RTN","ut1",84,0)
 I TAG'="" S TAG="!"_U_TAG
"RTN","ut1",85,0)
 Q TAG
"RTN","ut1",86,0)
 ;
"RTN","ut1",87,0)
CHKTAGS(LINE,TEST) ; check input LINE for TAG line, containing TEST as first test after comment
"RTN","ut1",88,0)
 N TAG,NOTE,CHAR
"RTN","ut1",89,0)
 I $E(LINE)=" " Q "" ; test entry must have a tag
"RTN","ut1",90,0)
 I $$UP(LINE)'[TEST Q ""  ; must have TEST declaration
"RTN","ut1",91,0)
 I $P($$UP(LINE),"TEST")["(" Q "" ; can't have an argument
"RTN","ut1",92,0)
 S TAG=$P(LINE," "),LINE=$P(LINE," ",2,400),NOTE=$P($$UP(LINE),TEST),LINE=$E(LINE,$L(NOTE)+5+1,$L(LINE))
"RTN","ut1",93,0)
 F  Q:NOTE=""  S CHAR=$E(NOTE),NOTE=$E(NOTE,2,$L(NOTE)) I " ;"'[CHAR Q  ;
"RTN","ut1",94,0)
 I $L(NOTE)'=0 Q "" ; @TEST must be first text on line
"RTN","ut1",95,0)
 F  Q:$E(LINE)'=" "  S LINE=$E(LINE,2,$L(LINE)) ; remove leading spaces from test info
"RTN","ut1",96,0)
 S TAG=TAG_U_LINE
"RTN","ut1",97,0)
 Q TAG
"RTN","ut1",98,0)
 ;
"RTN","ut1",99,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","ut1",100,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut1",101,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",102,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut1",103,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut1",104,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut1",105,0)
 I '$D(%utGUI) D
"RTN","ut1",106,0)
 . D SETIO
"RTN","ut1",107,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut1",108,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut1",109,0)
 . . I $D(%ut("BREAK")) W !,"Breaking on Failure" BREAK  ;
"RTN","ut1",110,0)
 . . Q
"RTN","ut1",111,0)
 . D RESETIO
"RTN","ut1",112,0)
 . Q
"RTN","ut1",113,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut1",114,0)
 Q
"RTN","ut1",115,0)
 ;
"RTN","ut1",116,0)
NVLDARG(API) ; generate message for invalid arguments to test
"RTN","ut1",117,0)
 N XTERMSG
"RTN","ut1",118,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",119,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut1",120,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut1",121,0)
 S XTERMSG="NO VALUES INPUT TO "_API_"^%ut - no evaluation possible"
"RTN","ut1",122,0)
 I '$D(%utGUI) D
"RTN","ut1",123,0)
 . D SETIO
"RTN","ut1",124,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut1",125,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut1",126,0)
 . . Q
"RTN","ut1",127,0)
 . D RESETIO
"RTN","ut1",128,0)
 . Q
"RTN","ut1",129,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut1",130,0)
 Q
"RTN","ut1",131,0)
 ;
"RTN","ut1",132,0)
SETIO ; Set M-Unit Device to write the results to...
"RTN","ut1",133,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",134,0)
 I $IO'=%ut("IO") S (IO(0),%ut("DEV","OLD"))=$IO USE %ut("IO") SET IO=$IO
"RTN","ut1",135,0)
 QUIT
"RTN","ut1",136,0)
 ;
"RTN","ut1",137,0)
RESETIO ; Reset $IO back to the original device if we changed it.
"RTN","ut1",138,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",139,0)
 I $D(%ut("DEV","OLD")) S IO(0)=%ut("IO") U %ut("DEV","OLD") S IO=$IO K %ut("DEV","OLD")
"RTN","ut1",140,0)
 QUIT
"RTN","ut1",141,0)
 ;
"RTN","ut1",142,0)
 ; VEN/SMH 17DEC2013 - Remove dependence on VISTA - Uppercase here instead of XLFSTR.
"RTN","ut1",143,0)
UP(X) ;
"RTN","ut1",144,0)
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
"RTN","ut1",145,0)
 ;
"RTN","ut1",146,0)
 ; COV modified to support handling more than one namespace for analyzing coverage in one run
"RTN","ut1",147,0)
COV(NMSPS,COVCODE,VERBOSITY) ; VEN/SMH - PUBLIC ENTRY POINT; Coverage calculations
"RTN","ut1",148,0)
 ; [.]NMSPS: Namespace of the routines to analyze. End with * to include all routines.
"RTN","ut1",149,0)
 ;       Not using * will only include the routine with NMSP name.
"RTN","ut1",150,0)
 ;       e.g. PSOM* will include all routines starting with PSOM
"RTN","ut1",151,0)
 ;            PSOM will only include PSOM.
"RTN","ut1",152,0)
 ; COVCODE: Mumps code to run over which coverage will be calculated. Typically Unit Tests.
"RTN","ut1",153,0)
 ; VERBOSITY (optional): Scalar from -1 to 3.
"RTN","ut1",154,0)
 ;    - -1 = Global output in ^TMP("%utCOVREPORT",$J)
"RTN","ut1",155,0)
 ;    - 0 = Print only total coverage
"RTN","ut1",156,0)
 ;    - 1 = Break down by routine
"RTN","ut1",157,0)
 ;    - 2 = Break down by routine and tag
"RTN","ut1",158,0)
 ;    - 3 = Break down by routine and tag, and print lines that didn't execute for each tag.
"RTN","ut1",159,0)
 ;
"RTN","ut1",160,0)
 ; ZEXCEPT: %utcovxx - SET and KILLED in this code at top level
"RTN","ut1",161,0)
 ; ZEXCEPT: %Monitor,%apiOBJ,DecomposeStatus,LineByLine,Start,Stop,System,class - not variables parts of classes
"RTN","ut1",162,0)
 ; ZEXCEPT: %utIO - NEWed and set in EN^%ut
"RTN","ut1",163,0)
 N COVER,COVERSAV,I,NMSP1,RTN,RTNS,ERR,STATUS
"RTN","ut1",164,0)
 W !,"Loading routines to test coverage...",!
"RTN","ut1",165,0)
 I ($$GETSYS^%ut()=47) D  ; GT.M only!
"RTN","ut1",166,0)
 . N NMSP S NMSP=$G(NMSPS)
"RTN","ut1",167,0)
 . D:NMSP]""  S NMSP="" F  S NMSP=$O(NMSPS(NMSP)) Q:NMSP=""  D
"RTN","ut1",168,0)
 .. N %ZR ; GT.M specific
"RTN","ut1",169,0)
 .. D SILENT^%RSEL(NMSP,"SRC") ; GT.M specific. On Cache use $O(^$R(RTN)).
"RTN","ut1",170,0)
 .. N RN S RN=""
"RTN","ut1",171,0)
 .. F  S RN=$O(%ZR(RN)) Q:RN=""  W RN," " D
"RTN","ut1",172,0)
 ... N L2 S L2=$T(+2^@RN)
"RTN","ut1",173,0)
 . . . S L2=$TR(L2,$C(9)," ") ; change tabs to spaces ; JLI 160316 inserted to replace above
"RTN","ut1",174,0)
 . . . I $E($P(L2," ",2),1,2)'=";;" K %ZR(RN) W !,"Routine "_RN_" removed from analysis, since it doesn't have the standard second line format",!
"RTN","ut1",175,0)
 .. M RTNS=%ZR
"RTN","ut1",176,0)
 .. K %ZR
"RTN","ut1",177,0)
 . Q
"RTN","ut1",178,0)
 ;
"RTN","ut1",179,0)
 I ($$GETSYS^%ut()=0) D  ; CACHE SPECIFIC
"RTN","ut1",180,0)
 . N NMSP S NMSP=$G(NMSPS)
"RTN","ut1",181,0)
 . D:NMSP]""  S NMSP="" F  S NMSP=$O(NMSPS(NMSP)) Q:NMSP=""  D
"RTN","ut1",182,0)
 . . S NMSP1=NMSP I NMSP["*" S NMSP1=$P(NMSP,"*")
"RTN","ut1",183,0)
 . . I $D(^$R(NMSP1)) S RTNS(NMSP1)=""
"RTN","ut1",184,0)
 . . I NMSP["*" S RTN=NMSP1 F  S RTN=$O(^$R(RTN)) Q:RTN'[NMSP1  S RTNS(RTN)=""
"RTN","ut1",185,0)
 . . Q
"RTN","ut1",186,0)
 . Q
"RTN","ut1",187,0)
 ;
"RTN","ut1",188,0)
 ; ZEXCEPT: CTRAP - not really a variable
"RTN","ut1",189,0)
 S VERBOSITY=+$G(VERBOSITY) ; Get 0 if not passed.
"RTN","ut1",190,0)
 ;
"RTN","ut1",191,0)
 ;
"RTN","ut1",192,0)
 N GL
"RTN","ut1",193,0)
 S GL=$NA(^TMP("%utCOVCOHORT",$J))
"RTN","ut1",194,0)
 I '$D(^TMP("%utcovrunning",$J)) K @GL
"RTN","ut1",195,0)
 D RTNANAL(.RTNS,GL) ; save off any current coverage data
"RTN","ut1",196,0)
 I '$D(^TMP("%utcovrunning",$J)) N EXIT S EXIT=0 D  Q:EXIT
"RTN","ut1",197,0)
 . K ^TMP("%utCOVCOHORTSAV",$J)
"RTN","ut1",198,0)
 . M ^TMP("%utCOVCOHORTSAV",$J)=^TMP("%utCOVCOHORT",$J)
"RTN","ut1",199,0)
 . K ^TMP("%utCOVRESULT",$J)
"RTN","ut1",200,0)
 . S ^TMP("%utcovrunning",$J)=1,%utcovxx=1
"RTN","ut1",201,0)
 . ;
"RTN","ut1",202,0)
 . I ($$GETSYS^%ut()=47) VIEW "TRACE":1:$NA(^TMP("%utCOVRESULT",$J))  ; GT.M START PROFILING
"RTN","ut1",203,0)
 . ;
"RTN","ut1",204,0)
 . I ($$GETSYS^%ut()=0) D  ; CACHE CODE TO START PROFILING
"RTN","ut1",205,0)
 . . N NMSP,NMSPV S NMSP="",NMSPV="" F  S NMSPV=$O(RTNS(NMSPV)) Q:NMSPV=""  S NMSP=NMSP_NMSPV_","
"RTN","ut1",206,0)
 . . S NMSP=$E(NMSP,1,$L(NMSP)-1)
"RTN","ut1",207,0)
 . . S STATUS=##class(%Monitor.System.LineByLine).Start($lb(NMSP),$lb("RtnLine"),$lb($j))
"RTN","ut1",208,0)
 . . I +STATUS'=1 D DecomposeStatus^%apiOBJ(STATUS,.ERR,"-d") F I=1:1:ERR W ERR(I),!
"RTN","ut1",209,0)
 . . I +STATUS'=1 K ERR S EXIT=1
"RTN","ut1",210,0)
 . . Q
"RTN","ut1",211,0)
 . Q
"RTN","ut1",212,0)
 DO  ; Run the code, but keep our variables to ourselves.
"RTN","ut1",213,0)
 . NEW $ETRAP,$ESTACK
"RTN","ut1",214,0)
 . I ($$GETSYS^%ut()=47) D  ; GT.M SPECIFIC
"RTN","ut1",215,0)
 . . SET $ETRAP="Q:($ES&$Q) -9 Q:$ES  W ""CTRL-C ENTERED"""
"RTN","ut1",216,0)
 . . ;USE $PRINCIPAL:(CTRAP=$C(3)) ; JLI 170403
"RTN","ut1",217,0)
 . . USE %utIO:(CTRAP=$C(3)) ; JLI 170403
"RTN","ut1",218,0)
 . . Q
"RTN","ut1",219,0)
 . NEW (DUZ,IO,COVCODE,U,DILOCKTM,DISYS,DT,DTIME,IOBS,IOF,IOM,ION,IOS,IOSL,IOST,IOT,IOXY,%utIO)
"RTN","ut1",220,0)
 . XECUTE COVCODE
"RTN","ut1",221,0)
 . Q
"RTN","ut1",222,0)
 ; GT.M STOP PROFILING if this is the original level that started it
"RTN","ut1",223,0)
 I $D(^TMP("%utcovrunning",$J)),$D(%utcovxx) D
"RTN","ut1",224,0)
 . I ($$GETSYS^%ut()=47) VIEW "TRACE":0:$NA(^TMP("%utCOVRESULT",$J)) ; GT.M SPECIFIC
"RTN","ut1",225,0)
 . I ($$GETSYS^%ut()=0) ; CACHE SPECIFIC
"RTN","ut1",226,0)
 . K %utcovxx,^TMP("%utcovrunning",$J)
"RTN","ut1",227,0)
 . Q
"RTN","ut1",228,0)
 ;
"RTN","ut1",229,0)
 I '$D(^TMP("%utcovrunning",$J)) D
"RTN","ut1",230,0)
 . I ($$GETSYS^%ut()=0) D  ; CACHE SPECIFIC CODE
"RTN","ut1",231,0)
 . . S COVERSAV=$NA(^TMP("%utCOVCOHORTSAV",$J)) K @COVERSAV
"RTN","ut1",232,0)
 . . S COVER=$NA(^TMP("%utCOVCOHORT",$J)) K @COVER
"RTN","ut1",233,0)
 . . D CACHECOV(COVERSAV,COVER)
"RTN","ut1",234,0)
 . . D TOTAGS(COVERSAV,0),TOTAGS(COVER,1)
"RTN","ut1",235,0)
 . . D ##class(%Monitor.System.LineByLine).Stop()
"RTN","ut1",236,0)
 . . Q
"RTN","ut1",237,0)
 . D COVCOV($NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J))) ; Venn diagram matching between globals
"RTN","ut1",238,0)
 . ; Report
"RTN","ut1",239,0)
 . I VERBOSITY=-1 D
"RTN","ut1",240,0)
 . . K ^TMP("%utCOVREPORT",$J)
"RTN","ut1",241,0)
 . . D COVRPTGL^%utcover($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),$NA(^TMP("%utCOVREPORT",$J)))
"RTN","ut1",242,0)
 . . K ^TMP("%utCOVCOHORTSAV",$J),^TMP("%utCOVCOHORT",$J),^TMP("%utCOVRESULT",$J) ; %utCOVREPORT contains the data for the user
"RTN","ut1",243,0)
 . . Q
"RTN","ut1",244,0)
 . E  D
"RTN","ut1",245,0)
 . . D COVRPT($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),VERBOSITY)
"RTN","ut1",246,0)
 . . K ^TMP("%utCOVCOHORTSAV",$J),^TMP("%utCOVCOHORT",$J),^TMP("%utCOVRESULT",$J),^TMP("%utCOVREPORT",$J)
"RTN","ut1",247,0)
 . . Q
"RTN","ut1",248,0)
 . Q
"RTN","ut1",249,0)
 QUIT
"RTN","ut1",250,0)
 ;
"RTN","ut1",251,0)
CACHECOV(GLOBSAV,GLOB) ;
"RTN","ut1",252,0)
 ; ZEXCEPT: %Monitor,GetMetrics,GetRoutineCount,GetRoutineName,LineByLine,System,class - not variable names, part of classes
"RTN","ut1",253,0)
 N %N,DIF,I,METRIC,METRICNT,METRICS,MTRICNUM,ROUNAME,ROUNUM,X,XCNP,XXX
"RTN","ut1",254,0)
 I $$ISUTEST(),'$D(^TMP("%utt4val",$J)) S ROUNUM=1,METRICS="RtnLine",METRICNT=1,ROUNAME="%ut"
"RTN","ut1",255,0)
 I $D(^TMP("%utt4val",$J))!'$$ISUTEST() S ROUNUM=##class(%Monitor.System.LineByLine).GetRoutineCount(),METRICS=##class(%Monitor.System.LineByLine).GetMetrics(),METRICNT=$l(METRICS,",")
"RTN","ut1",256,0)
 ; if only running to do coverage, should be 1
"RTN","ut1",257,0)
 S MTRICNUM=0 F I=1:1:METRICNT S METRIC=$P(METRICS,",",I) I METRIC="RtnLine" S MTRICNUM=I Q
"RTN","ut1",258,0)
 ;
"RTN","ut1",259,0)
 F I=1:1:ROUNUM D
"RTN","ut1",260,0)
 . I $D(^TMP("%utt4val",$J))!'$$ISUTEST() S ROUNAME=##class(%Monitor.System.LineByLine).GetRoutineName(I)
"RTN","ut1",261,0)
 . ; get routine loaded into location
"RTN","ut1",262,0)
 . S DIF=$NA(@GLOBSAV@(ROUNAME)),DIF=$E(DIF,1,$L(DIF)-1)_",",XCNP=0,X=ROUNAME
"RTN","ut1",263,0)
 . ;X ^%ZOSF("LOAD") ; JLI 160912 see 160701 note in comments at top
"RTN","ut1",264,0)
 . I $$GETSYS^%ut()=0 D
"RTN","ut1",265,0)
 . . X "N %,%N S %N=0 X ""ZL @X F XCNP=XCNP+1:1 S %N=%N+1,%=$T(+%N) Q:$L(%)=0  S @(DIF_XCNP_"""",0)"""")=%""" ; JLI see 160701 note in comments at top
"RTN","ut1",266,0)
 . . Q
"RTN","ut1",267,0)
 . I $$GETSYS^%ut()=47 D
"RTN","ut1",268,0)
 . . N % S %N=0 F XCNP=XCNP+1:1 S %N=%N+1,%=$T(+%N^@X) Q:$L(%)=0  S @(DIF_XCNP_",0)")=%
"RTN","ut1",269,0)
 . . Q
"RTN","ut1",270,0)
 . M @GLOB@(ROUNAME)=@GLOBSAV@(ROUNAME)
"RTN","ut1",271,0)
 . Q
"RTN","ut1",272,0)
 ;
"RTN","ut1",273,0)
 I $D(^TMP("%utt4val",$J))!'$$ISUTEST() F XXX=1:1:ROUNUM D GETVALS(XXX,GLOB,MTRICNUM)
"RTN","ut1",274,0)
 Q
"RTN","ut1",275,0)
 ;
"RTN","ut1",276,0)
GETVALS(ROUNUM,GLOB,MTRICNUM) ; get data on number of times a line seen (set into VAL)
"RTN","ut1",277,0)
 ; ZEXCEPT: %Monitor,%New,%ResultSet,Execute,GetData,GetRoutineName,LineByLine,Next,System,class - not variables parts of Cache classes
"RTN","ut1",278,0)
 N LINE,MORE,ROUNAME,RSET,VAL,X
"RTN","ut1",279,0)
 ;
"RTN","ut1",280,0)
 S RSET=##class(%ResultSet).%New("%Monitor.System.LineByLine:Result")
"RTN","ut1",281,0)
 S ROUNAME=##class(%Monitor.System.LineByLine).GetRoutineName(ROUNUM)
"RTN","ut1",282,0)
 S LINE=RSET.Execute(ROUNAME)
"RTN","ut1",283,0)
 F LINE=1:1 S MORE=RSET.Next() Q:'MORE  D
"RTN","ut1",284,0)
 . S X=RSET.GetData(1)
"RTN","ut1",285,0)
 . S VAL=$LI(X,MTRICNUM)
"RTN","ut1",286,0)
 . S @GLOB@(ROUNAME,LINE,"C")=+VAL ; values are 0 if not seen, otherwises positive number
"RTN","ut1",287,0)
 . Q
"RTN","ut1",288,0)
 D RSET.Close()
"RTN","ut1",289,0)
 Q
"RTN","ut1",290,0)
 ;
"RTN","ut1",291,0)
TOTAGS(GLOBAL,ACTIVE) ; convert to lines from tags and set value only if not seen
"RTN","ut1",292,0)
 N ACTIVCOD,LINE,LINENUM,ROU,ROUCODE
"RTN","ut1",293,0)
 S ROU="" F  S ROU=$O(@GLOBAL@(ROU)) Q:ROU=""  D
"RTN","ut1",294,0)
 . M ROUCODE(ROU)=@GLOBAL@(ROU) K @GLOBAL@(ROU)
"RTN","ut1",295,0)
 . N TAG,OFFSET,OLDTAG S TAG="",OFFSET=0,OLDTAG=""
"RTN","ut1",296,0)
 . F LINENUM=1:1 Q:'$D(ROUCODE(ROU,LINENUM,0))  D
"RTN","ut1",297,0)
 . . S LINE=ROUCODE(ROU,LINENUM,0)
"RTN","ut1",298,0)
 . . S ACTIVCOD=$$LINEDATA(LINE,.TAG,.OFFSET)
"RTN","ut1",299,0)
 . . I TAG'=OLDTAG S @GLOBAL@(ROU,TAG)=TAG
"RTN","ut1",300,0)
 . . I ACTIVE,ACTIVCOD,(+$G(ROUCODE(ROU,LINENUM,"C"))'>0) S @GLOBAL@(ROU,TAG,OFFSET)=LINE
"RTN","ut1",301,0)
 . . I 'ACTIVE,ACTIVCOD S @GLOBAL@(ROU,TAG,OFFSET)=LINE
"RTN","ut1",302,0)
 . . Q
"RTN","ut1",303,0)
 . Q
"RTN","ut1",304,0)
 Q
"RTN","ut1",305,0)
 ;
"RTN","ut1",306,0)
LINEDATA(LINE,TAG,OFFSET) ;
"RTN","ut1",307,0)
 ; LINE   - input - the line of code
"RTN","ut1",308,0)
 ; TAG    - passed by reference -
"RTN","ut1",309,0)
 ; OFFSET - passed by reference
"RTN","ut1",310,0)
 N CODE,NEWTAG
"RTN","ut1",311,0)
 S NEWTAG=""
"RTN","ut1",312,0)
 S OFFSET=$G(OFFSET)+1
"RTN","ut1",313,0)
 F  Q:$E(LINE,1)=" "  Q:$E(LINE,1)=$C(9)  Q:LINE=""  S NEWTAG=NEWTAG_$E(LINE,1),LINE=$E(LINE,2,$L(LINE))
"RTN","ut1",314,0)
 S NEWTAG=$P(NEWTAG,"(")
"RTN","ut1",315,0)
 I NEWTAG'="" S TAG=NEWTAG,OFFSET=0
"RTN","ut1",316,0)
 S CODE=1
"RTN","ut1",317,0)
 F  S:(LINE="")!($E(LINE)=";") CODE=0 Q:'CODE  Q:(" ."'[$E(LINE))  S LINE=$E(LINE,2,$L(LINE))
"RTN","ut1",318,0)
 Q CODE
"RTN","ut1",319,0)
 ;
"RTN","ut1",320,0)
RTNANAL(RTNS,GL) ; [Private] - Routine Analysis
"RTN","ut1",321,0)
 ; Create a global similar to the trace global produced by GT.M in GL
"RTN","ut1",322,0)
 ; Only non-comment lines are stored.
"RTN","ut1",323,0)
 ; A tag is always stored. Tag,0 is stored only if there is code on the tag line (format list or actual code).
"RTN","ut1",324,0)
 ; tags with no code don't count toward the total.
"RTN","ut1",325,0)
 ;
"RTN","ut1",326,0)
 N RTN S RTN=""
"RTN","ut1",327,0)
 F  S RTN=$O(RTNS(RTN)) Q:RTN=""  D                       ; for each routine
"RTN","ut1",328,0)
 . N TAG,LN,T
"RTN","ut1",329,0)
 . S LN=$T(+1^@RTN)
"RTN","ut1",330,0)
 . S TAG=$$GETTAG(.T,LN) ; JLI 160316 - don't assume first line tag is routine name
"RTN","ut1",331,0)
 . N I F I=2:1 S LN=$T(@TAG+I^@RTN) Q:LN=""  D         ; for each line, starting with the 3rd line (2 off the first tag)
"RTN","ut1",332,0)
 . . I $E(LN)?1A D  QUIT                                  ; formal line
"RTN","ut1",333,0)
 . . . S TAG=$$GETTAG(.T,LN)
"RTN","ut1",334,0)
 . . . S @GL@(RTN,TAG)=TAG                                ; store line
"RTN","ut1",335,0)
 . . . I T="(" D                                          ; formal list
"RTN","ut1",336,0)
 . . . . N PCNT,STR,CHR S PCNT=0,STR=$P(LN,"(",2,99)
"RTN","ut1",337,0)
 . . . . F  S CHR=$E(STR),STR=$E(STR,2,$L(STR)) Q:(PCNT=0)&(CHR=")")  D
"RTN","ut1",338,0)
 . . . . . I CHR="(" S PCNT=PCNT+1
"RTN","ut1",339,0)
 . . . . . I CHR=")" S PCNT=PCNT-1
"RTN","ut1",340,0)
 . . . . . Q
"RTN","ut1",341,0)
 . . . . S STR=$TR(STR,$C(9,32))
"RTN","ut1",342,0)
 . . . . I $E(STR)=";" QUIT  ; comment line - no code
"RTN","ut1",343,0)
 . . . . S @GL@(RTN,TAG,0)=LN
"RTN","ut1",344,0)
 . . . . Q
"RTN","ut1",345,0)
 . . . E  D                                               ; No formal list
"RTN","ut1",346,0)
 . . . . N LNTR S LNTR=$P(LN,TAG,2,999),LNTR=$TR(LNTR,$C(9,32)) ; Get rest of line, Remove spaces and tabs
"RTN","ut1",347,0)
 . . . . I $E(LNTR)=";" QUIT                              ; Comment
"RTN","ut1",348,0)
 . . . . S @GL@(RTN,TAG,0)=LN                             ; Otherwise, store for testing
"RTN","ut1",349,0)
 . . . S I=0                                              ; Start offsets from zero (first one at the for will be 1)
"RTN","ut1",350,0)
 . . I $C(32,9)[$E(LN) D  QUIT                            ; Regular line
"RTN","ut1",351,0)
 . . . N LNTR S LNTR=$TR(LN,$C(32,9,46))                     ; Remove all spaces and tabs - JLI 150202 remove periods as well
"RTN","ut1",352,0)
 . . . I $E(LNTR)=";" QUIT                                ; Comment line -- don't want.
"RTN","ut1",353,0)
 . . . S @GL@(RTN,TAG,I)=LN                               ; Record line
"RTN","ut1",354,0)
 QUIT
"RTN","ut1",355,0)
 ;
"RTN","ut1",356,0)
GETTAG(TERMINTR,LN) ;.EF - get TAG for line, if any
"RTN","ut1",357,0)
 ; TERMINTR - passed by reference - contains terminator of tag on return
"RTN","ut1",358,0)
 ; LN       - input               - text of line
"RTN","ut1",359,0)
 N J,TAG
"RTN","ut1",360,0)
 F J=1:1:$L(LN) S TERMINTR=$E(LN,J) Q:(TERMINTR'?1AN)&((J'=1)&(TERMINTR'="%"))          ; Loop to...
"RTN","ut1",361,0)
 S TAG=$E(LN,1,J-1)                                 ; Get tag
"RTN","ut1",362,0)
 Q TAG
"RTN","ut1",363,0)
 ;
"RTN","ut1",364,0)
ACTLINES(GL) ; [Private] $$ ; Count active lines
"RTN","ut1",365,0)
 ;
"RTN","ut1",366,0)
 N CNT S CNT=0
"RTN","ut1",367,0)
 N REF S REF=GL
"RTN","ut1",368,0)
 N GLQL S GLQL=$QL(GL)
"RTN","ut1",369,0)
 F  S REF=$Q(@REF) Q:REF=""  Q:(GL'=$NA(@REF,GLQL))  D
"RTN","ut1",370,0)
 . N REFQL S REFQL=$QL(REF)
"RTN","ut1",371,0)
 . N LASTSUB S LASTSUB=$QS(REF,REFQL)
"RTN","ut1",372,0)
 . ;I LASTSUB?1.N S CNT=CNT+1  ; JLI 160315 commented out
"RTN","ut1",373,0)
 . ; count only those with tag,number - not tags which are numbers only ; JLI 160315
"RTN","ut1",374,0)
 . I (LASTSUB?1.N)&($QL(REF)=5) S CNT=CNT+1 ; JLI 160315 replaces commented out line
"RTN","ut1",375,0)
 QUIT CNT
"RTN","ut1",376,0)
 ;
"RTN","ut1",377,0)
COVCOV(C,R) ; [Private] - Analyze coverage Cohort vs Result
"RTN","ut1",378,0)
 N RTN S RTN=""
"RTN","ut1",379,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D  ; For each routine in cohort set
"RTN","ut1",380,0)
 . I '$D(@R@(RTN)) QUIT             ; Not present in result set
"RTN","ut1",381,0)
 . N TAG S TAG=""
"RTN","ut1",382,0)
 . F  S TAG=$O(@R@(RTN,TAG)) Q:TAG=""  D  ; For each tag in the routine in the result set
"RTN","ut1",383,0)
 . . N LN S LN=""
"RTN","ut1",384,0)
 . . F  S LN=$O(@R@(RTN,TAG,LN)) Q:LN=""  D  ; for each line in the tag in the routine in the result set
"RTN","ut1",385,0)
 . . . I $D(@C@(RTN,TAG,LN)) K ^(LN)  ; if present in cohort, kill off
"RTN","ut1",386,0)
 QUIT
"RTN","ut1",387,0)
 ;
"RTN","ut1",388,0)
COVRPT(C,S,R,V) ; [Private] - Coverage Report
"RTN","ut1",389,0)
 ; C = COHORT    - Global name
"RTN","ut1",390,0)
 ; S = SURVIVORS - Global name
"RTN","ut1",391,0)
 ; R = RESULT    - Global name
"RTN","ut1",392,0)
 ; V = Verbosity - Scalar from -1 to 3
"RTN","ut1",393,0)
 ; JLI 150702 -  modified to be able to do unit tests on setting up the text via COVRPTLS
"RTN","ut1",394,0)
 N X,I
"RTN","ut1",395,0)
 S X=$NA(^TMP("%ut1-covrpt",$J)) K @X
"RTN","ut1",396,0)
 D COVRPTLS(C,S,R,V,X)
"RTN","ut1",397,0)
 I '$$ISUTEST^%ut() F I=1:1 W:$D(@X@(I)) !,@X@(I) I '$D(@X@(I)) K @X Q
"RTN","ut1",398,0)
 Q
"RTN","ut1",399,0)
 ;
"RTN","ut1",400,0)
COVRPTLS(C,S,R,V,X) ;
"RTN","ut1",401,0)
 ;
"RTN","ut1",402,0)
 N LINNUM S LINNUM=0
"RTN","ut1",403,0)
 N ORIGLINES S ORIGLINES=$$ACTLINES(C)
"RTN","ut1",404,0)
 N LEFTLINES S LEFTLINES=$$ACTLINES(S)
"RTN","ut1",405,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="",LINNUM=LINNUM+1,@X@(LINNUM)=""
"RTN","ut1",406,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="ORIG: "_ORIGLINES
"RTN","ut1",407,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="LEFT: "_LEFTLINES
"RTN","ut1",408,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="COVERAGE PERCENTAGE: "_$S(ORIGLINES:$J((ORIGLINES-LEFTLINES)/ORIGLINES*100,"",2),1:100.00)
"RTN","ut1",409,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="",LINNUM=LINNUM+1,@X@(LINNUM)=""
"RTN","ut1",410,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="BY ROUTINE:"
"RTN","ut1",411,0)
 I V=0 QUIT  ; No verbosity. Don't print routine detail
"RTN","ut1",412,0)
 N RTN S RTN=""
"RTN","ut1",413,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","ut1",414,0)
 . N O S O=$$ACTLINES($NA(@C@(RTN)))
"RTN","ut1",415,0)
 . N L S L=$$ACTLINES($NA(@S@(RTN)))
"RTN","ut1",416,0)
 . N XX,XY S XX="  "_RTN_"                    ",XX=$E(XX,1,12)
"RTN","ut1",417,0)
 . S XY="        "_$S(O:$J((O-L)/O*100,"",2)_"%",1:"------"),XY=$E(XY,$L(XY)-11,$L(XY))
"RTN","ut1",418,0)
 . I O>0 S LINNUM=LINNUM+1,@X@(LINNUM)=XX_XY_"  "_(O-L)_" out of "_O
"RTN","ut1",419,0)
 . I V=1 QUIT  ; Just print the routine coverage for V=1
"RTN","ut1",420,0)
 . N TAG S TAG=""
"RTN","ut1",421,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","ut1",422,0)
 . . N O S O=$$ACTLINES($NA(@C@(RTN,TAG)))
"RTN","ut1",423,0)
 . . N L S L=$$ACTLINES($NA(@S@(RTN,TAG)))
"RTN","ut1",424,0)
 . . S XX="    "_TAG_"                  ",XX=$E(XX,1,20)
"RTN","ut1",425,0)
 . . S XY="      "_$S(O:$J((O-L)/O*100,"",2)_"%",1:"------"),XY=$E(XY,$L(XY)-7,$L(XY))
"RTN","ut1",426,0)
 . . I O>0 S LINNUM=LINNUM+1,@X@(LINNUM)=XX_XY_"  "_(O-L)_" out of "_O
"RTN","ut1",427,0)
 . . I V=2 QUIT  ; Just print routine/tags coverage for V=2; V=3 print uncovered lines
"RTN","ut1",428,0)
 . . N LN S LN=""
"RTN","ut1",429,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  S LINNUM=LINNUM+1,@X@(LINNUM)=TAG_"+"_LN_": "_^(LN)
"RTN","ut1",430,0)
 . . Q
"RTN","ut1",431,0)
 . Q
"RTN","ut1",432,0)
 QUIT
"RTN","ut1",433,0)
 ;
"RTN","ut1",434,0)
ISUTEST() ;
"RTN","ut1",435,0)
 Q $$ISUTEST^%ut()
"RTN","utcover")
0^3^B86708312
"RTN","utcover",1,0)
%utcover ;JLI - generic coverage and unit test runner ;04/29/17  15:29
"RTN","utcover",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utcover",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utcover",4,0)
 ; Original routine authored by Joel L. Ivey 08/15.  Additional work 08/15-02/17.
"RTN","utcover",5,0)
 ;
"RTN","utcover",6,0)
 ; Changes:  (Moved from %ut and %ut1)
"RTN","utcover",7,0)
 ; 130726 SMH - Moved test collection logic from %utUNIT to here (multiple places)
"RTN","utcover",8,0)
 ; 131218 SMH - dependence on XLFSTR removed
"RTN","utcover",9,0)
 ; 131218 SMH - CHEKTEST refactored to use $TEXT instead of ^%ZOSF("LOAD")
"RTN","utcover",10,0)
 ; 131218 SMH - CATCHERR now nulls out $ZS if on GT.M
"RTN","utcover",11,0)
 ;
"RTN","utcover",12,0)
 ; ------- COMMENTS moved from %ut due to space requirements
"RTN","utcover",13,0)
 ;
"RTN","utcover",14,0)
 ; 100622 JLI - corrected typo in comments where %utINPT was listed as %utINP
"RTN","utcover",15,0)
 ; 100622 JLI - removed a comment which indicated data could potentially be returned from the called routine
"RTN","utcover",16,0)
 ;              in the %utINPT array.
"RTN","utcover",17,0)
 ; 100622 JLI - added code to handle STARTUP and SHUTDOWN from GUI app
"RTN","utcover",18,0)
 ; 110719 JLI - modified separators in GUI handling from ^ to ~~^~~
"RTN","utcover",19,0)
 ;              in the variable XTGUISEP if using a newer version of the
"RTN","utcover",20,0)
 ;              GUI app (otherwise, it is simply set to ^) since results
"RTN","utcover",21,0)
 ;              with a series of ^ embedded disturbed the output reported
"RTN","utcover",22,0)
 ; 130726 SMH - Fixed SETUP and TEARDOWN so that they run before/after each
"RTN","utcover",23,0)
 ;              test rather than once. General refactoring.
"RTN","utcover",24,0)
 ; 130726 SMH - SETUT initialized IO in case it's not there to $P. Inits vars
"RTN","utcover",25,0)
 ;              using DT^DICRW.
"RTN","utcover",26,0)
 ; 131217 SMH - Change call in SETUP to S U="^" instead of DT^DICRW
"RTN","utcover",27,0)
 ; 131218 SMH - Any checks to $ZE will also check $ZS for GT.M.
"RTN","utcover",28,0)
 ; 131218 SMH - Remove calls to %ZISUTL to manage devices to prevent dependence on VISTA.
"RTN","utcover",29,0)
 ;              Use %utNIT("DEV","OLD") for old devices
"RTN","utcover",30,0)
 ; 140109 SMH - Add parameter %utBREAK - Break upon error
"RTN","utcover",31,0)
 ; 1402   SMH - Break will cause the break to happen even on failed tests.
"RTN","utcover",32,0)
 ; 140401 SMH - Added Succeed entry point for take it into your hands tester.
"RTN","utcover",33,0)
 ; 140401 SMH - Reformatted the output of M-Unit so that the test's name
"RTN","utcover",34,0)
 ;              will print BEFORE the execution of the test. This has been
"RTN","utcover",35,0)
 ;              really confusing for beginning users of M-Unit, so this was
"RTN","utcover",36,0)
 ;              necessary.
"RTN","utcover",37,0)
 ; 140401 SMH - OK message gets printed at the end of --- as [OK].
"RTN","utcover",38,0)
 ; 140401 SMH - FAIL message now prints. Previously, OK failed to be printed.
"RTN","utcover",39,0)
 ;              Unfortunately, that's rather passive aggressive. Now it
"RTN","utcover",40,0)
 ;              explicitly says that a test failed.
"RTN","utcover",41,0)
 ; 140503 SMH - Fixed IO issues all over the routine. Much simpler now.
"RTN","utcover",42,0)
 ; 140731 JLI - Combined routine changes between JLI and SMH
"RTN","utcover",43,0)
 ;              Moved routines from %utNIT and %utNIT1 to %ut and %ut1
"RTN","utcover",44,0)
 ;              Updated unit test routines (%utt1 to %utt6)
"RTN","utcover",45,0)
 ;              Created M-UNIT TEST GROUP file at 17.9001 based on the 17.9001 file
"RTN","utcover",46,0)
 ; 141030 JLI - Removed tag TESTCOVR and code under it, not necessary
"RTN","utcover",47,0)
 ;              since %uttcovr can handle all of the calling needed
"RTN","utcover",48,0)
 ;              Added call to run routine %utt6 if run from the top,
"RTN","utcover",49,0)
 ;              since this will run the full range of unit tests
"RTN","utcover",50,0)
 ;              Modified STARTUP and SHUTDOWN commands to handle in
"RTN","utcover",51,0)
 ;              each routine where they are available, since only
"RTN","utcover",52,0)
 ;              running one STARTUP and SHUTDOWN (the first seen by
"RTN","utcover",53,0)
 ;              the program) restricted their use in suites of multiple
"RTN","utcover",54,0)
 ;              tests.
"RTN","utcover",55,0)
 ; 150101 JLI - Added COV entry to %ut (in addition to current in %ut1) so it is easier
"RTN","utcover",56,0)
 ;              to remember how to use it.
"RTN","utcover",57,0)
 ; 150621 JLI - Added a global location to pick up summary data for a unit test call, so
"RTN","utcover",58,0)
 ;              programs running multiple calls can generate a summary if desired.
"RTN","utcover",59,0)
 ;
"RTN","utcover",60,0)
 ; comments for this routine %utcover
"RTN","utcover",61,0)
 ; 160701 Christopher Edwards (CE) in COVENTRY to remove VistA dependence add U as NEWed variable and set U to '^'
"RTN","utcover",62,0)
 ; 160713 JLI - changed reference to JUSTTEST to MULTAPIS in description of TESTROUS variable for tag COVERAGE
"RTN","utcover",63,0)
 ; 170130 JLI - modified to permit COVERAGE to be called with ROUNMSP passed by reference to be able to use multiple namespaces (or to specify expicity those to be tested, so XCLDROUS can be null)
"RTN","utcover",64,0)
 ;
"RTN","utcover",65,0)
 D EN^%ut("%uttcovr") ; unit tests
"RTN","utcover",66,0)
 Q
"RTN","utcover",67,0)
 ;
"RTN","utcover",68,0)
MULTAPIS(TESTROUS) ; RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","utcover",69,0)
 ; can be run from %ut using D MULTAPIS^%ut(.TESTROUS)
"RTN","utcover",70,0)
 ; input TESTROUS - passed by reference - array of routine names to run tests for
"RTN","utcover",71,0)
 ;               specify those to be called directly by including ^ as part of
"RTN","utcover",72,0)
 ;               TAG^ROUTINE or ^ROUTINE.
"RTN","utcover",73,0)
 ;               ROUTINE names without a ^ will be called as EN^%ut("ROUTINE")
"RTN","utcover",74,0)
 ;               Sometimes to get complete coverage, different entry points may
"RTN","utcover",75,0)
 ;               need to be called (e.g., at top and for VERBOSE), these should each
"RTN","utcover",76,0)
 ;               be included.
"RTN","utcover",77,0)
 ;               If the subscript is a number, it will take the list of comma separated
"RTN","utcover",78,0)
 ;               values as the routines.  If the the subscript is not a number, it will
"RTN","utcover",79,0)
 ;               take it as a routine to be added to the list, then if the value of the
"RTN","utcover",80,0)
 ;               contains a comma separated list of routines, they will be added as well.
"RTN","utcover",81,0)
 ;               Thus a value of
"RTN","utcover",82,0)
 ;                 TESTROUS(1)="A^ROU1,^ROU1,^ROU2,ROU3"
"RTN","utcover",83,0)
 ;               or a value of
"RTN","utcover",84,0)
 ;                 TESTROUS("A^ROU1")="^ROU1,^ROU2,ROU3"
"RTN","utcover",85,0)
 ;               will both result in tests for
"RTN","utcover",86,0)
 ;                 D A^ROU1,^ROU1,^ROU2,EN^%ut("ROU3")
"RTN","utcover",87,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",88,0)
 M ^TMP("%utcover",$J,"TESTROUS")=TESTROUS
"RTN","utcover",89,0)
 D COVENTRY
"RTN","utcover",90,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",91,0)
 Q
"RTN","utcover",92,0)
 ;
"RTN","utcover",93,0)
COVENTRY ; setup of COVERAGE NEWs most variables, so TESTROUS passed by global
"RTN","utcover",94,0)
 ;
"RTN","utcover",95,0)
 N I,ROU,VAL,VALS,UTDATA,TESTS,TESTROUS,U ; CE 160701 add U as newed variable to remove VistA dependence
"RTN","utcover",96,0)
 S U="^" ; CE 160701 set U to remove VistA dependence
"RTN","utcover",97,0)
 M TESTROUS=^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",98,0)
 S ROU="" F  S ROU=$O(TESTROUS(ROU)) Q:ROU=""  D
"RTN","utcover",99,0)
 . I ROU'=+ROU S TESTS(ROU)=""
"RTN","utcover",100,0)
 . F I=1:1 S VAL=$P(TESTROUS(ROU),",",I) Q:VAL=""  S TESTS(VAL)=""
"RTN","utcover",101,0)
 . Q
"RTN","utcover",102,0)
 ;W !,"COVENTRY^%utcover TESTS:",! ZW TESTS
"RTN","utcover",103,0)
 S ROU="" F  S ROU=$O(TESTS(ROU)) Q:ROU=""  D  W !,"Coventry ROU=",ROU
"RTN","utcover",104,0)
 . W !!,"------------------- RUNNING ",ROU," -------------------",! ; JLI 160319 put CR after line so periods start on new line
"RTN","utcover",105,0)
 . I ROU[U D @ROU
"RTN","utcover",106,0)
 . I ROU'[U D @("EN^%ut("""_ROU_""")")
"RTN","utcover",107,0)
 . D GETUTVAL^%ut(.UTDATA)
"RTN","utcover",108,0)
 . Q
"RTN","utcover",109,0)
 I $D(UTDATA) D LSTUTVAL^%ut(.UTDATA)
"RTN","utcover",110,0)
 Q
"RTN","utcover",111,0)
 ;
"RTN","utcover",112,0)
COVERAGE(ROUNMSP,TESTROUS,XCLDROUS,RESLTLVL) ; run coverage analysis for multiple routines and entry points
"RTN","utcover",113,0)
 ; can be run from %ut using D COVERAGE^%ut(.ROUNMSP,.TESTROUS,.XCLDROUS,RESLTLVL)
"RTN","utcover",114,0)
 ; input ROUNMSP - Namespace for routine(s) to be analyzed
"RTN","utcover",115,0)
 ;                 ROUNAME will result in only the routine ROUNAME being analyzed
"RTN","utcover",116,0)
 ;                 ROUN* will result in all routines beginning with ROUN being analyzed
"RTN","utcover",117,0)
 ;     updated --  May be passed by reference, e.g. .NMSPCS
"RTN","utcover",118,0)
 ;                   where:
"RTN","utcover",119,0)
 ;                      NMSPCS="AAAA*"    could be the only input and include all routines beginning AAAA
"RTN","utcover",120,0)
 ;                      NMSPCS("BBBC")=""      would include only routine BBBC
"RTN","utcover",121,0)
 ;                      NMSPCS("BBBD*")=""     would include all routines beginning BBBD
"RTN","utcover",122,0)
 ; input TESTROUS - passed by reference - see TESTROUS description for MULTAPIS ; 160713 JUSTTEST changed to MULTAPIS
"RTN","utcover",123,0)
 ; input XCLDROUS - passed by reference - routines passed in a manner similar to TESTROUS,
"RTN","utcover",124,0)
 ;                  but only the routine names, whether as arguments or a comma separated
"RTN","utcover",125,0)
 ;                  list of routines, will be excluded from the analysis of coverage.  These
"RTN","utcover",126,0)
 ;                  would normally be names of routines which are only for unit tests, or
"RTN","utcover",127,0)
 ;                  others which should not be included in the analysis for some reason.
"RTN","utcover",128,0)
 ; input RESLTLVL - This value determines the amount of information to be generated for the
"RTN","utcover",129,0)
 ;                  analysis.  A missing or null value will be considered to be level 1
"RTN","utcover",130,0)
 ;                     1  -  Listing of analysis only for routine overall
"RTN","utcover",131,0)
 ;                     2  -  Listing of analysis for routine overall and for each TAG
"RTN","utcover",132,0)
 ;                     3  -  Full analysis for each tag, and lists out those lines which were
"RTN","utcover",133,0)
 ;                           not executed during the analysis
"RTN","utcover",134,0)
 ;
"RTN","utcover",135,0)
 ;W !,"ENTERING COVERAGE^%utcover" H 1 ; DEBUG
"RTN","utcover",136,0)
 N I,ROU,TYPE,XCLUDE,%utIO
"RTN","utcover",137,0)
 S %utIO=$I
"RTN","utcover",138,0)
 S RESLTLVL=$G(RESLTLVL,1)
"RTN","utcover",139,0)
 I (RESLTLVL<1) S RESLTLVL=1
"RTN","utcover",140,0)
 I (RESLTLVL>3) S RESLTLVL=3
"RTN","utcover",141,0)
 M ^TMP("%utcover",$J,"TESTROUS")=TESTROUS ;
"RTN","utcover",142,0)
 D COV^%ut1(.ROUNMSP,"D COVENTRY^%utcover",-1)
"RTN","utcover",143,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",144,0)
 S ROU="" F  S ROU=$O(XCLDROUS(ROU)) Q:ROU=""  D SETROUS(.XCLUDE,.XCLDROUS,ROU)
"RTN","utcover",145,0)
 N TEXTGLOB S TEXTGLOB=$NA(^TMP("%utcover-text",$J)) K @TEXTGLOB
"RTN","utcover",146,0)
 D LIST(.XCLUDE,RESLTLVL,TEXTGLOB)
"RTN","utcover",147,0)
 F I=1:1 Q:'$D(@TEXTGLOB@(I))  W !,@TEXTGLOB@(I)
"RTN","utcover",148,0)
 K @TEXTGLOB
"RTN","utcover",149,0)
 Q
"RTN","utcover",150,0)
 ;
"RTN","utcover",151,0)
SETROUS(XCLUDE,XCLDROUS,ROU) ;
"RTN","utcover",152,0)
 ; XCLUDE   - passed by reference - on return contains array with indices as routines to exclude from analysis
"RTN","utcover",153,0)
 ; XCLDROUS - passed by referenc - array may contain a comma-delimited list of routines to exclude from analysis
"RTN","utcover",154,0)
 ; ROU      - input - if non-numberic is name of routine to exclude from analysis
"RTN","utcover",155,0)
 N I,VAL
"RTN","utcover",156,0)
 I ROU'=+ROU S XCLUDE(ROU)=""
"RTN","utcover",157,0)
 F I=1:1 S VAL=$P(XCLDROUS(ROU),",",I) Q:VAL=""  S XCLUDE(VAL)=""
"RTN","utcover",158,0)
 Q
"RTN","utcover",159,0)
 ;
"RTN","utcover",160,0)
LIST(XCLDROUS,TYPE,TEXTGLOB,GLOB,LINNUM) ;
"RTN","utcover",161,0)
 ; ZEXCEPT: TYPE1  - NEWed and set below for recursion
"RTN","utcover",162,0)
 ; input - XCLDROUS - a comma separated list of routine names that will
"RTN","utcover",163,0)
 ;       be used to identify desired routines.  Any name
"RTN","utcover",164,0)
 ;       that begins with one of the specified values will
"RTN","utcover",165,0)
 ;       be included
"RTN","utcover",166,0)
 ; input - TYPE - value indicating amount of detail desired
"RTN","utcover",167,0)
 ;       3=full with listing of untouched lines
"RTN","utcover",168,0)
 ;       2=moderated with listing by tags
"RTN","utcover",169,0)
 ;       1=summary with listing by routine
"RTN","utcover",170,0)
 ; input - TEXTGLOB - closed global location in which text is returned
"RTN","utcover",171,0)
 ; input - GLOB - used for unit tests - specifies global to work with
"RTN","utcover",172,0)
 ;                so that coverage data is not impacted
"RTN","utcover",173,0)
 ;
"RTN","utcover",174,0)
 N CURRCOV,CURRLIN,LINCOV,LINE,LINTOT,ROULIST,ROUNAME,TAG,TOTCOV,TOTLIN,XVAL
"RTN","utcover",175,0)
 ;
"RTN","utcover",176,0)
 I '$D(LINNUM) S LINNUM=0 ; initialize on first entry
"RTN","utcover",177,0)
 I '$D(GLOB) N GLOB S GLOB=$NA(^TMP("%utCOVREPORT",$J))
"RTN","utcover",178,0)
 D TRIMDATA(.XCLDROUS,GLOB) ; remove undesired routines from data
"RTN","utcover",179,0)
 ;
"RTN","utcover",180,0)
 N JOB,NAME,BASE,TEXT,VAL
"RTN","utcover",181,0)
 S TOTCOV=0,TOTLIN=0
"RTN","utcover",182,0)
 ; F NAME="%utCOVREPORT","%utCOVRESULT","%utCOVCOHORT","%utCOVCOHORTSAV" D
"RTN","utcover",183,0)
 I TYPE>1 S ROUNAME="" F  S ROUNAME=$O(@GLOB@(ROUNAME)) Q:ROUNAME=""  S XVAL=^(ROUNAME) D
"RTN","utcover",184,0)
 . S CURRCOV=$P(XVAL,"/"),CURRLIN=$P(XVAL,"/",2)
"RTN","utcover",185,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",186,0)
 . S TEXT="Routine "_ROUNAME_"              ",TEXT=$E(TEXT,1,20)
"RTN","utcover",187,0)
 . I CURRLIN>0 S VAL="     ("_$J((100*CURRCOV)/CURRLIN,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",188,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=TEXT_"   "_$S(CURRLIN>0:VAL_"%)",1:"  ------ ")_"   "_CURRCOV_" out of "_CURRLIN_" lines covered"
"RTN","utcover",189,0)
 . I TYPE>1 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="  - "_$S(TYPE=2:"Summary",1:"Detailed Breakdown")
"RTN","utcover",190,0)
 . S TAG="" F  S TAG=$O(@GLOB@(ROUNAME,TAG)) Q:TAG=""  S XVAL=^(TAG) D
"RTN","utcover",191,0)
 . . S LINCOV=$P(XVAL,"/"),LINTOT=$P(XVAL,"/",2)
"RTN","utcover",192,0)
 . . S TEXT=" Tag "_TAG_"^"_ROUNAME_"                ",TEXT=$E(TEXT,1,26)
"RTN","utcover",193,0)
 . . I LINTOT>0 S VAL="     ("_$J((100*LINCOV)/LINTOT,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",194,0)
 . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=TEXT_$S(LINTOT>0:VAL_"%)",1:"  ------ ")_"   "_LINCOV_" out of "_LINTOT_" lines covered"
"RTN","utcover",195,0)
 . . I TYPE=2 Q
"RTN","utcover",196,0)
 . . I LINCOV=LINTOT Q
"RTN","utcover",197,0)
 . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="   the following is a list of the lines **NOT** covered"
"RTN","utcover",198,0)
 . . S LINE="" F  S LINE=$O(@GLOB@(ROUNAME,TAG,LINE)) Q:LINE=""  D
"RTN","utcover",199,0)
 . . . I LINE=0 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="     "_TAG_"  "_@GLOB@(ROUNAME,TAG,LINE) Q
"RTN","utcover",200,0)
 . . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="     "_TAG_"+"_LINE_"  "_@GLOB@(ROUNAME,TAG,LINE)
"RTN","utcover",201,0)
 . . . Q
"RTN","utcover",202,0)
 . . Q
"RTN","utcover",203,0)
 . Q
"RTN","utcover",204,0)
 ; for type=3 generate a summary at bottom after detail
"RTN","utcover",205,0)
 I TYPE=3 N TYPE1 S TYPE1=2 D LIST(.XCLDROUS,2,TEXTGLOB,GLOB,.LINNUM) K TYPE1
"RTN","utcover",206,0)
 I TYPE=2,$G(TYPE1) Q  ; CAME IN FROM ABOVE LINE
"RTN","utcover",207,0)
 ; summarize by just routine name
"RTN","utcover",208,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",209,0)
 S ROUNAME="" F  S ROUNAME=$O(@GLOB@(ROUNAME)) Q:ROUNAME=""  S XVAL=^(ROUNAME) D
"RTN","utcover",210,0)
 . S CURRCOV=$P(XVAL,"/"),CURRLIN=$P(XVAL,"/",2)
"RTN","utcover",211,0)
 . S TOTCOV=TOTCOV+CURRCOV,TOTLIN=TOTLIN+CURRLIN
"RTN","utcover",212,0)
 . I CURRLIN>0 S VAL="     ("_$J((100*CURRCOV)/CURRLIN,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",213,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="Routine "_ROUNAME_"     "_$S(CURRLIN>0:VAL_"%)",1:"  ------ ")_"   "_CURRCOV_" out of "_CURRLIN_" lines covered"
"RTN","utcover",214,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",215,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="Overall Analysis "_TOTCOV_" out of "_TOTLIN_" lines covered"_$S(TOTLIN>0:" ("_$P((100*TOTCOV)/TOTLIN,".")_"% coverage)",1:"")
"RTN","utcover",216,0)
 Q
"RTN","utcover",217,0)
 ;
"RTN","utcover",218,0)
TRIMDATA(ROULIST,GLOB) ;
"RTN","utcover",219,0)
 N ROUNAME
"RTN","utcover",220,0)
 S ROUNAME="" F  S ROUNAME=$O(ROULIST(ROUNAME)) Q:ROUNAME=""  K @GLOB@(ROUNAME)
"RTN","utcover",221,0)
 Q
"RTN","utcover",222,0)
 ;
"RTN","utcover",223,0)
CHKLEAKS(%utCODE,%utLOC,%utINPT) ; functionality to check for variable leaks on executing a section of code
"RTN","utcover",224,0)
 ; %utCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
"RTN","utcover",225,0)
 ;            this should be a complete piece of code (e.g., "S X=$$NOW^XLFDT()" or "D EN^%ut(""ROUNAME"")")
"RTN","utcover",226,0)
 ; %utLOC  - A string that is used to indicate the code tested for variable leaks
"RTN","utcover",227,0)
 ; %utINPT - An optional variable which may be passed by reference.  This may
"RTN","utcover",228,0)
 ;           be used to pass any variable values, etc. into the code to be
"RTN","utcover",229,0)
 ;           XECUTED.  In this case, set the subscript to the variable name and the
"RTN","utcover",230,0)
 ;           value of the subscripted variable to the desired value of the subscript.
"RTN","utcover",231,0)
 ;              e.g., (using NAME as my current namespace)
"RTN","utcover",232,0)
 ;                   S CODE="S %utINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
"RTN","utcover",233,0)
 ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
"RTN","utcover",234,0)
 ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
"RTN","utcover",235,0)
 ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
"RTN","utcover",236,0)
 ;                   D CHKLEAKS^%ut(CODE,NAMELOC,.NAMEINPT)
"RTN","utcover",237,0)
 ;
"RTN","utcover",238,0)
 ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
"RTN","utcover",239,0)
 ;           from running the code with the variables indicated will be shown as FAILUREs.
"RTN","utcover",240,0)
 ;
"RTN","utcover",241,0)
 ;           If called outside of a unit test, any leaked variables will be printed to the
"RTN","utcover",242,0)
 ;           current device.
"RTN","utcover",243,0)
 ;
"RTN","utcover",244,0)
 N (%utCODE,%utLOC,%utINPT,DUZ,IO,U,%utERRL,%ut,%utGUI,%utERR,%utI,%utJ,%utK,%utLIST,%utROU,%utSTRT,XTGUISEP)
"RTN","utcover",245,0)
 ; ZEXCEPT: %ut - part of exclusive NEW TESTS FOR EXISTENCE ONLY
"RTN","utcover",246,0)
 ; ZEXCEPT: %utVAR - handled by exclusive NEW
"RTN","utcover",247,0)
 ;
"RTN","utcover",248,0)
 ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO %utINPT TO THEIR VALUES
"RTN","utcover",249,0)
 S %utVAR=" " F  S %utVAR=$O(%utINPT(%utVAR)) Q:%utVAR=""  S (@%utVAR)=%utINPT(%utVAR)
"RTN","utcover",250,0)
 X %utCODE
"RTN","utcover",251,0)
 N ZZUTVAR S ZZUTVAR="%"
"RTN","utcover",252,0)
 I $G(%ut)=1 D
"RTN","utcover",253,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","utcover",254,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","utcover",255,0)
 . Q
"RTN","utcover",256,0)
 I '($G(%ut)=1) D
"RTN","utcover",257,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","utcover",258,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","utcover",259,0)
 . Q
"RTN","utcover",260,0)
 Q
"RTN","utcover",261,0)
 ;
"RTN","utcover",262,0)
 ; MOVED FROM %ut1 due to size requirements
"RTN","utcover",263,0)
COVRPTGL(C,S,R,OUT) ; [Private] - Coverage Global for silent invokers
"RTN","utcover",264,0)
 ; C = COHORT    - Global name
"RTN","utcover",265,0)
 ; S = SURVIVORS - Global name
"RTN","utcover",266,0)
 ; R = RESULT    - Global name
"RTN","utcover",267,0)
 ; OUT = OUTPUT  - Global name
"RTN","utcover",268,0)
 ;
"RTN","utcover",269,0)
 N O S O=$$ACTLINES^%ut1(C)
"RTN","utcover",270,0)
 N L S L=$$ACTLINES^%ut1(S)
"RTN","utcover",271,0)
 S @OUT=(O-L)_"/"_O
"RTN","utcover",272,0)
 N RTN,TAG,LN S (RTN,TAG,LN)=""
"RTN","utcover",273,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","utcover",274,0)
 . N O S O=$$ACTLINES^%ut1($NA(@C@(RTN)))
"RTN","utcover",275,0)
 . N L S L=$$ACTLINES^%ut1($NA(@S@(RTN)))
"RTN","utcover",276,0)
 . S @OUT@(RTN)=(O-L)_"/"_O
"RTN","utcover",277,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","utcover",278,0)
 . . N O S O=$$ACTLINES^%ut1($NA(@C@(RTN,TAG)))
"RTN","utcover",279,0)
 . . N L S L=$$ACTLINES^%ut1($NA(@S@(RTN,TAG)))
"RTN","utcover",280,0)
 . . S @OUT@(RTN,TAG)=(O-L)_"/"_O
"RTN","utcover",281,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  S @OUT@(RTN,TAG,LN)=@S@(RTN,TAG,LN)
"RTN","utcover",282,0)
 QUIT
"RTN","utcover",283,0)
 ;
"RTN","utt1")
0^4^B47228039
"RTN","utt1",1,0)
%utt1 ; VEN/SMH-JLI - Testing routines for M-Unit;04/26/17  21:41
"RTN","utt1",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt1",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt1",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt1",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-12/2015
"RTN","utt1",6,0)
 ; Modifications made by Sam H. Habiel 02/2016
"RTN","utt1",7,0)
 ;
"RTN","utt1",8,0)
 ; THIS ROUTINE IS THE UNIFIED UNIT TESTER FOR ALL OF M-UNIT.
"RTN","utt1",9,0)
 ;
"RTN","utt1",10,0)
 ; Dear Users,
"RTN","utt1",11,0)
 ;
"RTN","utt1",12,0)
 ; I know about about the irony of a test suite for the testing suite,
"RTN","utt1",13,0)
 ; so stop snikering. Aside from that, it's actually going to be hard.
"RTN","utt1",14,0)
 ;
"RTN","utt1",15,0)
 ; Truly yours,
"RTN","utt1",16,0)
 ;
"RTN","utt1",17,0)
 ; Sam H
"RTN","utt1",18,0)
 ;
"RTN","utt1",19,0)
 W !,"Running tests in NON-VERBOSE mode",!,"For Verbose mode use DO VERBOSE^%utt1(ARG) where ARG is an integer 1 to 3"
"RTN","utt1",20,0)
 N X R !,"ENTER RETURN TO CONTINUE: ",X:3
"RTN","utt1",21,0)
 D EN^%ut($T(+0)) ; Run tests here, be non-verbose.
"RTN","utt1",22,0)
 Q
"RTN","utt1",23,0)
 ;
"RTN","utt1",24,0)
VERBOSE(VERBSITY) ;
"RTN","utt1",25,0)
 I (+$G(VERBSITY)<1)!($G(VERBSITY)>3) N VERBSITY S VERBSITY=3
"RTN","utt1",26,0)
 W !!,"Running tests in VERBOSE mode with "_$S(VERBSITY=1:"no timing",VERBSITY=2:"whole millisecond timing",3:"fractional millisecond timing"),!
"RTN","utt1",27,0)
 D EN^%ut($T(+0),VERBSITY) ; Run tests here, be verbose.
"RTN","utt1",28,0)
 QUIT
"RTN","utt1",29,0)
 ;
"RTN","utt1",30,0)
STARTUP ; M-Unit Start-Up - This runs before anything else.
"RTN","utt1",31,0)
 ; ZEXCEPT: KBANCOUNT - created here, removed in SHUTDOWN
"RTN","utt1",32,0)
 S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt1",33,0)
 S KBANCOUNT=1
"RTN","utt1",34,0)
 QUIT
"RTN","utt1",35,0)
 ;
"RTN","utt1",36,0)
SHUTDOWN ; M-Unit Shutdown - This runs after everything else is done.
"RTN","utt1",37,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed here
"RTN","utt1",38,0)
 K ^TMP($J,"%ut","STARTUP")
"RTN","utt1",39,0)
 K KBANCOUNT
"RTN","utt1",40,0)
 QUIT
"RTN","utt1",41,0)
 ;
"RTN","utt1",42,0)
 ;
"RTN","utt1",43,0)
 ;
"RTN","utt1",44,0)
SETUP ; This runs before every test.
"RTN","utt1",45,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",46,0)
 S KBANCOUNT=KBANCOUNT+1
"RTN","utt1",47,0)
 QUIT
"RTN","utt1",48,0)
 ;
"RTN","utt1",49,0)
TEARDOWN ; This runs after every test
"RTN","utt1",50,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",51,0)
 S KBANCOUNT=KBANCOUNT-1
"RTN","utt1",52,0)
 QUIT
"RTN","utt1",53,0)
 ;
"RTN","utt1",54,0)
 ;
"RTN","utt1",55,0)
 ;
"RTN","utt1",56,0)
T1 ; @TEST - Make sure Start-up Ran
"RTN","utt1",57,0)
 D CHKTF($D(^TMP($J,"%ut","STARTUP")),"Start-up node on ^TMP must exist")
"RTN","utt1",58,0)
 QUIT
"RTN","utt1",59,0)
 ;
"RTN","utt1",60,0)
T2 ; @TEST - Make sure Set-up runs
"RTN","utt1",61,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",62,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not incremented properly at SETUP")
"RTN","utt1",63,0)
 QUIT
"RTN","utt1",64,0)
 ;
"RTN","utt1",65,0)
T3 ; @TEST - Make sure Teardown runs
"RTN","utt1",66,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",67,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not decremented properly at TEARDOWN")
"RTN","utt1",68,0)
 QUIT
"RTN","utt1",69,0)
 ;
"RTN","utt1",70,0)
T4 ; Specified in XTMTAG
"RTN","utt1",71,0)
 ; 140731 JLI - note that this will fail when run from the GUI runner, since it calls each tag separately
"RTN","utt1",72,0)
 ; ZEXCEPT: %utETRY - newed and created in EN1^%ut
"RTN","utt1",73,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT^%ut
"RTN","utt1",74,0)
 I $G(%utGUI) D CHKEQ(%utETRY,"T4","T4 should be the value for %utETRY in the GUI Runner")
"RTN","utt1",75,0)
 I '$G(%utGUI) D CHKEQ(%utETRY(4),"T4","T4 should be the collected as the fourth entry in %utETRY")
"RTN","utt1",76,0)
 QUIT
"RTN","utt1",77,0)
 ;
"RTN","utt1",78,0)
T5 ; ditto
"RTN","utt1",79,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt1",80,0)
 D CHKTF(0,"This is an intentional failure")
"RTN","utt1",81,0)
 D CHKEQ(%ut("FAIL"),1,"By this point, we should have failed one test")
"RTN","utt1",82,0)
 D FAIL^%ut("Intentionally throwing a failure")
"RTN","utt1",83,0)
 D CHKEQ(%ut("FAIL"),2,"By this point, we should have failed two tests")
"RTN","utt1",84,0)
 ; S %ut("FAIL")=0 ; Okay... Boy's and Girls... as the developer I can do that.
"RTN","utt1",85,0)
 QUIT
"RTN","utt1",86,0)
 ;
"RTN","utt1",87,0)
T6 ; ditto
"RTN","utt1",88,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt1",89,0)
 N TESTCOUNT S TESTCOUNT=%ut("CHK")
"RTN","utt1",90,0)
 D SUCCEED^%ut
"RTN","utt1",91,0)
 D SUCCEED^%ut
"RTN","utt1",92,0)
 D CHKEQ(%ut("CHK"),TESTCOUNT+2,"Succeed should increment the number of tests")
"RTN","utt1",93,0)
 QUIT
"RTN","utt1",94,0)
 ;
"RTN","utt1",95,0)
T7 ; Make sure we write to principal even though we are on another device
"RTN","utt1",96,0)
 ; This is a rather difficult test to carry out for GT.M and Cache...
"RTN","utt1",97,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt1",98,0)
 N D
"RTN","utt1",99,0)
 I $$GETSYS^%ut()=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",100,0)
 I $$GETSYS^%ut()=0 D  ; All Cache
"RTN","utt1",101,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",102,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",103,0)
 I $$GETSYS^%ut()=0 O D:"NWS" ; Cache new file
"RTN","utt1",104,0)
 I $$GETSYS^%ut()=47 O D:(newversion) ; GT.M new file
"RTN","utt1",105,0)
 U D
"RTN","utt1",106,0)
 WRITE "HELLO",!
"RTN","utt1",107,0)
 WRITE "HELLO",!
"RTN","utt1",108,0)
 C D
"RTN","utt1",109,0)
 ;
"RTN","utt1",110,0)
 ; Now open back the file, and read the hello, but open in read only so
"RTN","utt1",111,0)
 ; M-Unit will error out if it will write something out there.
"RTN","utt1",112,0)
 ;
"RTN","utt1",113,0)
 I $$GETSYS^%ut()=0 O D:"R"
"RTN","utt1",114,0)
 I $$GETSYS^%ut()=47 O D:(readonly)
"RTN","utt1",115,0)
 U D
"RTN","utt1",116,0)
 N X READ X:1
"RTN","utt1",117,0)
 D CHKTF(X="HELLO")  ; This should write to the screen the dot not to the file.
"RTN","utt1",118,0)
 D CHKTF(($$LO($IO)=$$LO(D)),"IO device didn't get reset back")       ; $$LO is b/c of a bug in Cache/Windows. $IO is not the same cas D.
"RTN","utt1",119,0)
 I $$GETSYS^%ut()=0 C D:"D"
"RTN","utt1",120,0)
 I $$GETSYS^%ut()=47 C D:(delete)
"RTN","utt1",121,0)
 U $P
"RTN","utt1",122,0)
 S IO=$IO
"RTN","utt1",123,0)
 QUIT
"RTN","utt1",124,0)
 ;
"RTN","utt1",125,0)
 ; At the moment T8^%utt1 throws a fail, with no message
"RTN","utt1",126,0)
 ; in the GUI runner.  For some reason, both X and Y
"RTN","utt1",127,0)
 ; variables are returned as null strings, while in the
"RTN","utt1",128,0)
 ; command line runner, Y has a value containing the
"RTN","utt1",129,0)
 ; word being sought
"RTN","utt1",130,0)
 ;
"RTN","utt1",131,0)
T8 ; If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",132,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt1",133,0)
 ; ZEXCEPT: %utGUI - if present, defined and killed elsewhere
"RTN","utt1",134,0)
 I $D(%utGUI) Q  ; GUI doesn't run verbose
"RTN","utt1",135,0)
 N D
"RTN","utt1",136,0)
 I $$GETSYS^%ut()=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",137,0)
 I $$GETSYS^%ut()=0 D  ; All Cache
"RTN","utt1",138,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",139,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",140,0)
 I $$GETSYS^%ut()=0 O D:"NWS" ; Cache new file
"RTN","utt1",141,0)
 I $$GETSYS^%ut()=47 O D:(newversion) ; GT.M new file
"RTN","utt1",142,0)
 S IO=D
"RTN","utt1",143,0)
 U D
"RTN","utt1",144,0)
 D ^%utt4 ; Run some Unit Tests
"RTN","utt1",145,0)
 C D
"RTN","utt1",146,0)
 I $$GETSYS^%ut()=0 O D:"R" ; Cache read only
"RTN","utt1",147,0)
 I $$GETSYS^%ut()=47 O D:(readonly) ; GT.M read only
"RTN","utt1",148,0)
 U D
"RTN","utt1",149,0)
 N X,Y,Z,Z1,Z2,Z3,Z4 R X:1,Y:1,Z:1,Z1:1,Z2:1,Z3:1,Z4:1
"RTN","utt1",150,0)
 I $$GETSYS^%ut()=0 C D:"D"
"RTN","utt1",151,0)
 I $$GETSYS^%ut()=47 C D:(delete)
"RTN","utt1",152,0)
 D CHKTF(Z1["MAIN","Write to system during test didn't work")
"RTN","utt1",153,0)
 S IO=$P,IO(0)=IO
"RTN","utt1",154,0)
 QUIT
"RTN","utt1",155,0)
 ;
"RTN","utt1",156,0)
COVRPTGL ;
"RTN","utt1",157,0)
 N GL1,GL2,GL3,GL4
"RTN","utt1",158,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","utt1",159,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","utt1",160,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","utt1",161,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","utt1",162,0)
 D SETGLOBS^%uttcovr(GL1,GL2)
"RTN","utt1",163,0)
 D COVRPTGL^%utcover(GL1,GL2,GL3,GL4)
"RTN","utt1",164,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES")),"0/9","Wrong number of lines covered f>>or ACTLINES")
"RTN","utt1",165,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES",9))," QUIT CNT","Wrong result for last l>>ine not covered for ACTLINES")
"RTN","utt1",166,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST")),"8/10","Wrong number of lines covered >>for CHEKTEST")
"RTN","utt1",167,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST",39))," . Q","Wrong result for last line >>not covered for CHEKTEST")
"RTN","utt1",168,0)
 K @GL1,@GL2,@GL3,@GL4
"RTN","utt1",169,0)
 Q
"RTN","utt1",170,0)
 ;
"RTN","utt1",171,0)
LO(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
"RTN","utt1",172,0)
 ; Shortcut methods for M-Unit
"RTN","utt1",173,0)
CHKTF(X,Y) ;
"RTN","utt1",174,0)
 D CHKTF^%ut(X,$G(Y))
"RTN","utt1",175,0)
 QUIT
"RTN","utt1",176,0)
 ;
"RTN","utt1",177,0)
CHKEQ(A,B,M) ;
"RTN","utt1",178,0)
 D CHKEQ^%ut(A,B,$G(M))
"RTN","utt1",179,0)
 QUIT
"RTN","utt1",180,0)
 ;
"RTN","utt1",181,0)
XTENT ; Entry points
"RTN","utt1",182,0)
 ;;T4;Entry point using XTMENT
"RTN","utt1",183,0)
 ;;T5;Error count check
"RTN","utt1",184,0)
 ;;T6;Succeed Entry Point
"RTN","utt1",185,0)
 ;;T7;Make sure we write to principal even though we are on another device
"RTN","utt1",186,0)
 ;;T8;If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",187,0)
 ;;COVRPTGL;coverage report returning global
"RTN","utt1",188,0)
 ;
"RTN","utt1",189,0)
XTROU ; Routines containing additional tests
"RTN","utt1",190,0)
 ;;%utt2; old %utNITU
"RTN","utt1",191,0)
 ;;%utt4; old %utNITW
"RTN","utt1",192,0)
 ;;%utt5;
"RTN","utt1",193,0)
 ;;%utt6;
"RTN","utt1",194,0)
 ;;%uttcovr;coverage related tests
"RTN","utt2")
0^5^B685355
"RTN","utt2",1,0)
%utt2 ; VEN/SMH - Bad Ass Continuation of Unit Tests;02/06/17  13:48
"RTN","utt2",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt2",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt2",4,0)
 ; Original routine authored by Sam H. Habiel
"RTN","utt2",5,0)
 ; Modifications made by Joel L. Ivey 05/2014-09/2015
"RTN","utt2",6,0)
 ;
"RTN","utt2",7,0)
%ut ;  List of changes in routine %ut in version 1.5
"RTN","utt2",8,0)
 ; 160713 JLI in ERROR1 moved actual BREAK on error, if BREAK option is specified from first executable line so actual error is listed before BREAK occurs
"RTN","utt2",9,0)
 ; 161020 JLI when BREAKing due to use of BREAK option, added code to indicate breaking on a false or nonequal value, or if breaking on an error the type of error causing the break
"RTN","utt2",10,0)
 ; 161113 JLI in EN1 added code to insert routine names before list of tags executed in verbose mode
"RTN","utt2",11,0)
 ; 161204 SMH added verbosity options for executions timing for tests to verbose output vaue 2 gives milliseconds or 3 gives microseconds expressed as fractional milliseconds
"RTN","utt2",12,0)
 ; 161204 SMH added tags GTMVER and ZHDIF related to execution timing
"RTN","utt2",13,0)
 ; 161206 JLI added tag GETSYS to handle cases where in Cache Windows systems with a computer name beginning with a digit are not correctly identified - originally reported by Steve Graham
"RTN","utt2",14,0)
 ; 161206 JLI changed all references to +$SY to calls to $$GETSYS in this routine
"RTN","utt2",15,0)
 ; 170111 JLI added code to work with SMH changes to %ut1 to permit single or multiple namespaces be passed for coverage analysis
"RTN","utt2",16,0)
 ;
"RTN","utt2",17,0)
%ut1 ; List of changes made in routine %ut1 in version 1.5
"RTN","utt2",18,0)
 ; 160316 JLI Modified checks that prevented some routines from being included in tests (e.g., name on line 1 doesn't match) or excluding, but notifying user if a routine looks like computer generated (no ;; 2nd line)
"RTN","utt2",19,0)
 ; 160701 Christopher Edwards (CE) suggested removing VistA dependence in CACHECOV+12 replaced ^%ZOSF("LOAD") with its code
"RTN","utt2",20,0)
 ; 161020 JLI on FAIL if BREAK was active added message indicating breaking on failure before actual BREAK
"RTN","utt2",21,0)
 ; 161206 JLI changed all references to +$SY to calls to $$GETSYS in %ut
"RTN","utt2",22,0)
 ; 161226 SMH added code to permit single or multiple namespaces be passed for coverage analysis
"RTN","utt2",23,0)
 ;
"RTN","utt2",24,0)
T11 ; @TEST An @TEST Entry point in Another Routine invoked through XTROU offsets
"RTN","utt2",25,0)
 D CHKTF^%ut(1)
"RTN","utt2",26,0)
 QUIT
"RTN","utt2",27,0)
T12 ;
"RTN","utt2",28,0)
 D CHKTF^%ut(1)
"RTN","utt2",29,0)
 QUIT
"RTN","utt2",30,0)
XTENT ;
"RTN","utt2",31,0)
 ;;T12;An XTENT offset entry point in Another Routine invoked through XTROU offsets
"RTN","utt3")
0^6^B1628564
"RTN","utt3",1,0)
%utt3 ; VEN/SMH-JLI - Unit Tests Coverage Tests;04/08/16  20:38
"RTN","utt3",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt3",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt3",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt3",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","utt3",6,0)
 ;
"RTN","utt3",7,0)
XTMUNITV ; VEN/SMH - Unit Tests Coverage Tests;2014-04-16  7:14 PM
"RTN","utt3",8,0)
 ;
"RTN","utt3",9,0)
 ; *** BE VERY CAREFUL IN MODIFIYING THIS ROUTINE ***
"RTN","utt3",10,0)
 ; *** THE UNIT TEST COUNTS ACTIVE AND INACTIVE LINES OF CODE ***
"RTN","utt3",11,0)
 ; *** IF YOU MODIFY THIS, MODIFY XTMUNITW AS WELL ***
"RTN","utt3",12,0)
 ;
"RTN","utt3",13,0)
 ; Coverage tester in %utt4
"RTN","utt3",14,0)
 ; 20 Lines of code
"RTN","utt3",15,0)
 ; 5 do not run as they are dead code
"RTN","utt3",16,0)
 ; Expected Coverage: 15/20 = 75%
"RTN","utt3",17,0)
 ;
"RTN","utt3",18,0)
STARTUP ; Doesn't count
"RTN","utt3",19,0)
 N X    ; Counts
"RTN","utt3",20,0)
 S X=1  ; Counts
"RTN","utt3",21,0)
 QUIT   ; Counts
"RTN","utt3",22,0)
 ;
"RTN","utt3",23,0)
SHUTDOWN K X,Y QUIT     ; Counts; ZEXCEPT: X,Y
"RTN","utt3",24,0)
 ;
"RTN","utt3",25,0)
SETUP S Y=$G(Y)+1 QUIT  ; Counts
"RTN","utt3",26,0)
 ;
"RTN","utt3",27,0)
TEARDOWN ; Doesn't count
"RTN","utt3",28,0)
 S Y=Y-1 ; Counts
"RTN","utt3",29,0)
 QUIT    ; Counts
"RTN","utt3",30,0)
 ;
"RTN","utt3",31,0)
T1 ; @TEST Test 1
"RTN","utt3",32,0)
 D CHKTF^%ut($D(Y)) ; Counts
"RTN","utt3",33,0)
 QUIT                   ; Counts
"RTN","utt3",34,0)
 ;
"RTN","utt3",35,0)
T2 ; @TEST Test 2
"RTN","utt3",36,0)
 D INTERNAL(1)          ; Counts
"RTN","utt3",37,0)
 D CHKTF^%ut(1)     ; Counts
"RTN","utt3",38,0)
 QUIT                   ; Counts
"RTN","utt3",39,0)
 S X=1                  ; Dead code
"RTN","utt3",40,0)
 QUIT                   ; Dead code
"RTN","utt3",41,0)
 ;
"RTN","utt3",42,0)
INTERNAL(A) ; Counts
"RTN","utt3",43,0)
 S A=A+1    ; Counts
"RTN","utt3",44,0)
 QUIT       ; Counts
"RTN","utt3",45,0)
 S A=2      ; Dead code
"RTN","utt3",46,0)
 S Y=2      ; Dead code
"RTN","utt3",47,0)
 QUIT       ; Dead code
"RTN","utt4")
0^7^B3071162
"RTN","utt4",1,0)
%utt4 ; VEN/SMH/JLI - Coverage Test Runner;01/30/17  11:46
"RTN","utt4",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt4",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt4",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt4",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","utt4",6,0)
 ;
"RTN","utt4",7,0)
XTMUNITW ; VEN/SMH - Coverage Test Runner;2014-04-17  3:30 PM
"RTN","utt4",8,0)
 ;;7.3;KERNEL TOOLKIT;;
"RTN","utt4",9,0)
 ;
"RTN","utt4",10,0)
 ; This tests code in XTMUNITV for coverage
"RTN","utt4",11,0)
 D EN^%ut($T(+0),1)
"RTN","utt4",12,0)
 QUIT
"RTN","utt4",13,0)
 ;
"RTN","utt4",14,0)
MAIN ; @TEST - Test coverage calculations
"RTN","utt4",15,0)
 Q:$D(^TMP("%uttcovr",$J))  ; already running coverage analysis from %uttcovr
"RTN","utt4",16,0)
 Q:$D(^TMP("%utCOVREPORT",$J))  ; another coverage already running
"RTN","utt4",17,0)
 S ^TMP("%utt4val",$J)=1
"RTN","utt4",18,0)
 D COV^%ut("%utt3","D EN^%ut(""%utt3"",1)",-1)  ; Only produce output global.
"RTN","utt4",19,0)
 D CHKEQ^%ut("14/19",^TMP("%utCOVREPORT",$J))
"RTN","utt4",20,0)
 D CHKEQ^%ut("2/5",^TMP("%utCOVREPORT",$J,"%utt3","INTERNAL"))
"RTN","utt4",21,0)
 D CHKTF^%ut($D(^TMP("%utCOVREPORT",$J,"%utt3","T2",4)))
"RTN","utt4",22,0)
 D CHKEQ^%ut("1/1",^TMP("%utCOVREPORT",$J,"%utt3","SETUP"))
"RTN","utt4",23,0)
 K ^TMP("%utt4val",$J)
"RTN","utt4",24,0)
 QUIT
"RTN","utt4",25,0)
 ;
"RTN","utt4",26,0)
 ; The following code was copied from the routine XLFDT so that unit tests for LEAKSOK
"RTN","utt4",27,0)
 ; and LEAKSBAD in %utt5 could be independent of VA KERNEL code'
"RTN","utt4",28,0)
 ;
"RTN","utt4",29,0)
HTFM(%H,%F) ;$H to FM, %F=1 for date only
"RTN","utt4",30,0)
 N X,%,%T,%Y,%M,%D S:'$D(%F) %F=0
"RTN","utt4",31,0)
 I $$HR(%H) Q -1 ;Check Range
"RTN","utt4",32,0)
 I '%F,%H[",0" S %H=(%H-1)_",86400"
"RTN","utt4",33,0)
 D YMD S:%T&('%F) X=X_%T
"RTN","utt4",34,0)
 Q X
"RTN","utt4",35,0)
 ;
"RTN","utt4",36,0)
YMD ;21608 = 28 feb 1900, 94657 = 28 feb 2100, 141 $H base year
"RTN","utt4",37,0)
 S %=(%H>21608)+(%H>94657)+%H-.1,%Y=%\365.25+141,%=%#365.25\1
"RTN","utt4",38,0)
 S %D=%+306#(%Y#4=0+365)#153#61#31+1,%M=%-%D\29+1
"RTN","utt4",39,0)
 S X=%Y_"00"+%M_"00"+%D,%=$P(%H,",",2)
"RTN","utt4",40,0)
 S %T=%#60/100+(%#3600\60)/100+(%\3600)/100 S:'%T %T=".0"
"RTN","utt4",41,0)
 Q
"RTN","utt4",42,0)
 ;
"RTN","utt4",43,0)
NOW() ;Current Date/time in FM.
"RTN","utt4",44,0)
 Q $$HTFM($H)
"RTN","utt4",45,0)
 ;
"RTN","utt4",46,0)
HR(%V) ;Check $H in valid range
"RTN","utt4",47,0)
 Q (%V<2)!(%V>99999)
"RTN","utt4",48,0)
 ;
"RTN","utt5")
0^8^B26349822
"RTN","utt5",1,0)
%utt5 ;JLI - test for aspects of MUnit functionality ;04/05/17  15:36
"RTN","utt5",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt5",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt5",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015.
"RTN","utt5",5,0)
 ;
"RTN","utt5",6,0)
 D ^%utt1
"RTN","utt5",7,0)
 Q
"RTN","utt5",8,0)
 ;
"RTN","utt5",9,0)
OLDSTYLE ;
"RTN","utt5",10,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",11,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",12,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYLE",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYLE")=""
"RTN","utt5",13,0)
 D CHKEQ^%ut(5,5,"SET EQUAL ON PURPOSE - OLDSTYLE DONE")
"RTN","utt5",14,0)
 D CHKTF^%ut(4=4,"MY EQUAL VALUE")
"RTN","utt5",15,0)
 Q
"RTN","utt5",16,0)
 ;
"RTN","utt5",17,0)
OLDSTYL1 ;
"RTN","utt5",18,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",19,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",20,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYL1",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYL1")=""
"RTN","utt5",21,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - OLDSTYL1 DONE")
"RTN","utt5",22,0)
 Q
"RTN","utt5",23,0)
 ;
"RTN","utt5",24,0)
NEWSTYLE ; @TEST identify new style test indicator functionality
"RTN","utt5",25,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",26,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",27,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"NEWSTYLE")=""
"RTN","utt5",28,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - NEWSTYLE DONE")
"RTN","utt5",29,0)
 Q
"RTN","utt5",30,0)
 ;
"RTN","utt5",31,0)
BADCHKEQ ;
"RTN","utt5",32,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",33,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",34,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKEQ" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKEQ")=""
"RTN","utt5",35,0)
 D CHKEQ^%ut(4,3,"SET UNEQUAL ON PURPOSE - SHOULD FAIL")
"RTN","utt5",36,0)
 Q
"RTN","utt5",37,0)
 ;
"RTN","utt5",38,0)
BADCHKTF ;
"RTN","utt5",39,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",40,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",41,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKTF" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKTF")=""
"RTN","utt5",42,0)
 D CHKTF^%ut(0,"SET FALSE (0) ON PURPOSE - SHOULD FAIL")
"RTN","utt5",43,0)
 Q
"RTN","utt5",44,0)
 ;
"RTN","utt5",45,0)
BADERROR ;
"RTN","utt5",46,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",47,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",48,0)
 N X
"RTN","utt5",49,0)
 I $D(%utt6var) S %ut("ENT")="BADERROR" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADERROR")=""
"RTN","utt5",50,0)
 ; following syntax error is on purpose to throw an error
"RTN","utt5",51,0)
 S X= ; syntax error on purpose
"RTN","utt5",52,0)
 Q
"RTN","utt5",53,0)
 ;
"RTN","utt5",54,0)
CALLFAIL ;
"RTN","utt5",55,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",56,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",57,0)
 N X
"RTN","utt5",58,0)
 I $D(%utt6var) S %ut("ENT")="CALLFAIL" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"CALLFAIL")=""
"RTN","utt5",59,0)
 D FAIL^%ut("Called FAIL to test it")
"RTN","utt5",60,0)
 Q
"RTN","utt5",61,0)
 ;
"RTN","utt5",62,0)
LEAKSOK ;
"RTN","utt5",63,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",64,0)
 ;S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSOK TEST",MYVALS("X")="" ; JLI 160912 replaced by code in next line so it is independent of VA KERNEL
"RTN","utt5",65,0)
 S CODE="S X=$$NOW^%utt4()",LOCATN="LEAKSOK TEST",MYVALS("X")=""  ; JLI 160912 replaced call to XLFDT with same code in %utt4 so it is independent of VA KERNEL
"RTN","utt5",66,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find no leaks
"RTN","utt5",67,0)
 Q
"RTN","utt5",68,0)
 ;
"RTN","utt5",69,0)
LEAKSBAD ;
"RTN","utt5",70,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",71,0)
 ;S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED" ; JLI 160912 replaced by code in next line so it is independent of VA KERNEL
"RTN","utt5",72,0)
 S CODE="S X=$$NOW^%utt4()",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED"  ; JLI 160912 replaced call to XLFDT with same code in %utt4 so it is independent of VA KERNEL
"RTN","utt5",73,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find X since it isn't indicated
"RTN","utt5",74,0)
 Q
"RTN","utt5",75,0)
 ;
"RTN","utt5",76,0)
NVLDARG1 ;
"RTN","utt5",77,0)
 D CHKEQ^%ut(1)
"RTN","utt5",78,0)
 Q
"RTN","utt5",79,0)
 ;
"RTN","utt5",80,0)
ISUTEST ;
"RTN","utt5",81,0)
 D CHKTF^%ut($$ISUTEST^%ut,"ISUTEST returned FALSE!")
"RTN","utt5",82,0)
 Q
"RTN","utt5",83,0)
 ;
"RTN","utt5",84,0)
BADFORM1(X) ; @TEST should not be selected - arguments
"RTN","utt5",85,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",86,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",87,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM1")=""
"RTN","utt5",88,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - ARGUMENTS - BADFORM1")
"RTN","utt5",89,0)
 Q
"RTN","utt5",90,0)
 ;
"RTN","utt5",91,0)
BADFORM2 ; ABC @TEST should not be selected - @TEST NOT FIRST
"RTN","utt5",92,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",93,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",94,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM2")=""
"RTN","utt5",95,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - @TEST NOT FIRST - BADFORM2")
"RTN","utt5",96,0)
 Q
"RTN","utt5",97,0)
 ;
"RTN","utt5",98,0)
STARTUP ;
"RTN","utt5",99,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",100,0)
 ; ZEXCEPT: KBANCOUNT created here, killed in SHUTDOWN
"RTN","utt5",101,0)
 I $D(%utt6var),$D(^TMP("%utt5",$J)) K ^TMP("%utt5",$J)
"RTN","utt5",102,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"STARTUP")=""
"RTN","utt5",103,0)
 ; following brought from %utt1, since only one STARTUP can RUN in a set
"RTN","utt5",104,0)
 I '$D(%utt6var) D
"RTN","utt5",105,0)
 . S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt5",106,0)
 . S KBANCOUNT=1
"RTN","utt5",107,0)
 . Q
"RTN","utt5",108,0)
 Q
"RTN","utt5",109,0)
 ;
"RTN","utt5",110,0)
SHUTDOWN ;
"RTN","utt5",111,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",112,0)
 ; ZEXCEPT: KBANCOUNT created in STARTUP, killed here
"RTN","utt5",113,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SHUTDOWN")=""
"RTN","utt5",114,0)
 ; following brought from %utt1, since only one SHUTDOWN can RUN in a set
"RTN","utt5",115,0)
 I '$D(%utt6var) D
"RTN","utt5",116,0)
 . K ^TMP($J,"%ut","STARTUP")
"RTN","utt5",117,0)
 . K KBANCOUNT
"RTN","utt5",118,0)
 . Q
"RTN","utt5",119,0)
 Q
"RTN","utt5",120,0)
 ;
"RTN","utt5",121,0)
SETUP ;
"RTN","utt5",122,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",123,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SETUP")=""
"RTN","utt5",124,0)
 Q
"RTN","utt5",125,0)
 ;
"RTN","utt5",126,0)
TEARDOWN ;
"RTN","utt5",127,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",128,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"TEARDOWN")=""
"RTN","utt5",129,0)
 Q
"RTN","utt5",130,0)
 ;
"RTN","utt5",131,0)
XTENT ;
"RTN","utt5",132,0)
 ;;OLDSTYLE; identify old style test indicator functionality
"RTN","utt5",133,0)
 ;;OLDSTYL1; identify old style test indicator 2
"RTN","utt5",134,0)
 ;;BADCHKEQ; CHKEQ should fail on unequal value
"RTN","utt5",135,0)
 ;;BADCHKTF; CHKTF should fail on false value
"RTN","utt5",136,0)
 ;;BADERROR; throws an error on purpose
"RTN","utt5",137,0)
 ;;CALLFAIL; called FAIL to test it
"RTN","utt5",138,0)
 ;;LEAKSOK;check leaks should be ok
"RTN","utt5",139,0)
 ;;LEAKSBAD;check leaks with leak
"RTN","utt5",140,0)
 ;;NVLDARG1;check invalid arg in CHKEQ
"RTN","utt5",141,0)
 ;;ISUTEST;check ISUTEST inside unit test
"RTN","utt6")
0^9^B41667626
"RTN","utt6",1,0)
%utt6 ;JLI - Unit tests for MUnit functionality ;04/26/17  16:26
"RTN","utt6",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt6",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt6",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015
"RTN","utt6",5,0)
 ;
"RTN","utt6",6,0)
 ;
"RTN","utt6",7,0)
 ; The counts for the command line processing are based on the number of unit test tags
"RTN","utt6",8,0)
 ; determined for the GUI processing as well.  The numbers are 2 (startup and shutdown)
"RTN","utt6",9,0)
 ;  + 3 x the number of tests present.
"RTN","utt6",10,0)
 ;
"RTN","utt6",11,0)
 ; run unit tests by command line
"RTN","utt6",12,0)
 N VERBOSE
"RTN","utt6",13,0)
 S VERBOSE=0
"RTN","utt6",14,0)
 D VERBOSE
"RTN","utt6",15,0)
 Q
"RTN","utt6",16,0)
 ;
"RTN","utt6",17,0)
VERBOSE3 ;
"RTN","utt6",18,0)
 N VERBOSE
"RTN","utt6",19,0)
 S VERBOSE=3
"RTN","utt6",20,0)
 D VERBOSE
"RTN","utt6",21,0)
 Q
"RTN","utt6",22,0)
 ;
"RTN","utt6",23,0)
VERBOSE2 ;
"RTN","utt6",24,0)
 N VERBOSE
"RTN","utt6",25,0)
 S VERBOSE=2
"RTN","utt6",26,0)
 D VERBOSE
"RTN","utt6",27,0)
 Q
"RTN","utt6",28,0)
 ;
"RTN","utt6",29,0)
VERBOSE ;
"RTN","utt6",30,0)
 I '$D(VERBOSE) N VERBOSE S VERBOSE=1
"RTN","utt6",31,0)
 N ZZUTCNT,UTTCNT,UTTEXPCT,UTTI,UTTX,ZZUTRSLT,%utt5,%utt6,%utt6var
"RTN","utt6",32,0)
 I $T(+1^DIC)'="" D CMNDLINE
"RTN","utt6",33,0)
 W !!,"NOW RUNNING UNIT TESTS FOR %uttcovr",!!
"RTN","utt6",34,0)
 D EN^%ut("%uttcovr",VERBOSE)
"RTN","utt6",35,0)
 ;
"RTN","utt6",36,0)
 ; now run the unit tests in this routine
"RTN","utt6",37,0)
 W !!,"NOW RUNNING UNIT TESTS FOR %utt6",!!
"RTN","utt6",38,0)
 D EN^%ut("%utt6",VERBOSE)
"RTN","utt6",39,0)
 K ^TMP("%utt5",$J),^TMP("%utt5_C",$J),^TMP("%utt5_G",$J),^TMP("%utt6",$J),^TMP("%utt6_GUISET",$J)
"RTN","utt6",40,0)
 ; clean up after GUI calls as well
"RTN","utt6",41,0)
 K ^TMP("GUI-MUNIT",$J),^TMP("GUINEXT",$J),^TMP("MUNIT-%utRSLT",$J)
"RTN","utt6",42,0)
 Q
"RTN","utt6",43,0)
 ;
"RTN","utt6",44,0)
CMNDLINE ;
"RTN","utt6",45,0)
 N %utt6
"RTN","utt6",46,0)
 I '$D(VERBOSE) N VERBOSE S VERBOSE=1
"RTN","utt6",47,0)
 W !!,"RUNNING COMMAND LINE TESTS VIA DOSET^%ut",!
"RTN","utt6",48,0)
 D DOSET^%ut(1,VERBOSE) ; run `1 in M-UNIT TEST GROUP file
"RTN","utt6",49,0)
 ;
"RTN","utt6",50,0)
 W !!!,"Running command line tests by RUNSET^%ut",!
"RTN","utt6",51,0)
 D RUNSET^%ut("TESTS FOR UNIT TEST ROUTINES")
"RTN","utt6",52,0)
 ;
"RTN","utt6",53,0)
 ; Call GUISET to obtain list of tags via entry in M-UNIT TEST GROUP file
"RTN","utt6",54,0)
 ; silent to the user
"RTN","utt6",55,0)
 D GUISET^%ut(.%utt6,1)
"RTN","utt6",56,0)
 K ^TMP("%utt6_GUISET",$J) M ^TMP("%utt6_GUISET",$J)=@%utt6
"RTN","utt6",57,0)
 ;
"RTN","utt6",58,0)
 W !!!,"RUNNING COMMAND LINE UNIT TESTS FOR %utt5",!
"RTN","utt6",59,0)
 N ZZUTCNT,UTTCNT,UTTEXPCT,UTTI,UTTX,ZZUTRSLT
"RTN","utt6",60,0)
 S ZZUTCNT=0
"RTN","utt6",61,0)
 K ^TMP("%utt5",$J) ; kill any contents of data storage
"RTN","utt6",62,0)
 D EN^%ut("%utt5",VERBOSE) ; should do STARTUP(1x), then SETUP, test, TEARDOWN (each together 3x) and SHUTDOWN (1x)
"RTN","utt6",63,0)
 K ^TMP("%utt5_C",$J) M ^TMP("%utt5_C",$J)=^TMP("%utt5",$J)
"RTN","utt6",64,0)
 ;
"RTN","utt6",65,0)
 ; now run unit tests by GUI - first determines unit test tags
"RTN","utt6",66,0)
 W !!!,"RUNNING UNIT TESTS FOR %utt5 VIA GUI CALLS - Silent",!
"RTN","utt6",67,0)
 S ZZUTCNT=0
"RTN","utt6",68,0)
 K ^TMP("%utt5",$J),^TMP("%utt6",$J)
"RTN","utt6",69,0)
 D GUILOAD^%ut(.%utt6,"%utt5")
"RTN","utt6",70,0)
 M ^TMP("%utt6",$J)=@%utt6
"RTN","utt6",71,0)
 S %utt6=$NA(^TMP("%utt6",$J))
"RTN","utt6",72,0)
 ; then run each tag separately
"RTN","utt6",73,0)
 ; UTTCNT is count of unit test tags, which can be determined for GUI call for each unit test tag
"RTN","utt6",74,0)
 S UTTCNT=0 F UTTI=1:1 S UTTX=$G(@%utt6@(UTTI)) Q:UTTX=""  I $P(UTTX,U,2)'="" S UTTCNT=UTTCNT+1 D GUINEXT^%ut(.ZZUTRSLT,$P(UTTX,U,2)_U_$P(UTTX,U))
"RTN","utt6",75,0)
 ; and close it with a null routine name
"RTN","utt6",76,0)
 D GUINEXT^%ut(.ZZUTRSLT,"")
"RTN","utt6",77,0)
 K ^TMP("%utt5_G",$J) M ^TMP("%utt5_G",$J)=^TMP("%utt5",$J)
"RTN","utt6",78,0)
 S UTTEXPCT=2+(3*UTTCNT) ; number of lines that should be in the global nodes for command line and GUI
"RTN","utt6",79,0)
 Q
"RTN","utt6",80,0)
 ;
"RTN","utt6",81,0)
 ;           WARNING     --      WARNING     --      WARNING
"RTN","utt6",82,0)
 ; If the number of NEW STYLE tests in %utt5 is increased (it is currently 1), then the following
"RTN","utt6",83,0)
 ; test will need to be updated to reflect the change(s)
"RTN","utt6",84,0)
 ;     END OF WARNING  --  END OF WARNING  --  END OF WARNING
"RTN","utt6",85,0)
 ;
"RTN","utt6",86,0)
SETROUS ; @TEST - generate array with indices of routines to exclude
"RTN","utt6",87,0)
 N ROU,XCLDROUS,ROULIST
"RTN","utt6",88,0)
 S XCLDROUS(1)="ROU1NAME,ROU2NAME"
"RTN","utt6",89,0)
 S XCLDROUS("ROUNAME3")="ROUNAME4,ROUNAME5"
"RTN","utt6",90,0)
 D SETROUS^%utcover(.ROULIST,.XCLDROUS,1)
"RTN","utt6",91,0)
 D CHKTF('$D(ROULIST(1)),"SETROUS returned number for routine")
"RTN","utt6",92,0)
 D CHKTF($D(ROULIST("ROU1NAME")),"Didn't get first name on numeric subscript")
"RTN","utt6",93,0)
 D CHKTF($D(ROULIST("ROU2NAME")),"Didn't get second name on numeric subscript")
"RTN","utt6",94,0)
 D SETROUS^%utcover(.ROULIST,.XCLDROUS,"ROUNAME3")
"RTN","utt6",95,0)
 D CHKTF($D(ROULIST("ROUNAME3")),"Didn't get name for routine argument")
"RTN","utt6",96,0)
 D CHKTF($D(ROULIST("ROUNAME4")),"Didn't get first name on routine subscript")
"RTN","utt6",97,0)
 D CHKTF($D(ROULIST("ROUNAME5")),"Didn't get second name on routine subscript")
"RTN","utt6",98,0)
 Q
"RTN","utt6",99,0)
 ;
"RTN","utt6",100,0)
NEWSTYLE ; tests return of valid new style or @TEST indicators
"RTN","utt6",101,0)
 N LIST
"RTN","utt6",102,0)
 D NEWSTYLE^%ut1(.LIST,"%utt5")
"RTN","utt6",103,0)
 D CHKEQ^%ut(LIST,1,"Returned an incorrect number ("_LIST_") of New Style indicators - should be one")
"RTN","utt6",104,0)
 I LIST>0 D CHKEQ^%ut(LIST(1),"@^NEWSTYLE^identify new style test indicator functionality","Returned incorrect TAG^reason "_LIST(1))
"RTN","utt6",105,0)
 I LIST>0 D CHKEQ^%ut($G(LIST(2)),"","Returned a value for LIST(2) - should not have any value (i.e., null)")
"RTN","utt6",106,0)
 ; the following is basically just for coverage
"RTN","utt6",107,0)
 D PICKSET^%ut
"RTN","utt6",108,0)
 Q
"RTN","utt6",109,0)
 ;
"RTN","utt6",110,0)
CKGUISET ;
"RTN","utt6",111,0)
 ; ZEXCEPT: %utt6var - if present, is NEWed and created in code following VERBOSE
"RTN","utt6",112,0)
 I '$D(%utt6var) Q
"RTN","utt6",113,0)
 N MAX
"RTN","utt6",114,0)
 S MAX=$O(^TMP("%utt6_GUISET",$J,""),-1)
"RTN","utt6",115,0)
 D CHKTF(^TMP("%utt6_GUISET",$J,MAX)["%utt6^NEWSTYLE","GUISET returned incorrect list")
"RTN","utt6",116,0)
 Q
"RTN","utt6",117,0)
 ;
"RTN","utt6",118,0)
CHKCMDLN ; check command line processing of %utt5
"RTN","utt6",119,0)
 ; ZEXCEPT: UTTEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",120,0)
 I '$D(%utt6var) Q
"RTN","utt6",121,0)
 D CHKTF($D(^TMP("%utt5_C",$J,UTTEXPCT))=10,"Not enough entries in %utt5 expected "_UTTEXPCT)
"RTN","utt6",122,0)
 D CHKTF($D(^TMP("%utt5_C",$J,UTTEXPCT+1))=0,"Too many entries in %utt5 expected "_UTTEXPCT)
"RTN","utt6",123,0)
 D CHKTF($O(^TMP("%utt5_C",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5_C",$J,1,""))_"' should be 'STARTUP'")
"RTN","utt6",124,0)
 D CHKTF($O(^TMP("%utt5_C",$J,UTTEXPCT,""))="SHUTDOWN","Incorrect function for entry "_UTTEXPCT_", '"_$O(^TMP("%utt5_C",$J,UTTEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",125,0)
 Q
"RTN","utt6",126,0)
 ;
"RTN","utt6",127,0)
CHKGUI ; check GUI processing of %utt5
"RTN","utt6",128,0)
 ; ZEXCEPT: UTTEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",129,0)
 I '$D(%utt6var) Q
"RTN","utt6",130,0)
 D CHKTF($D(^TMP("%utt5_G",$J,UTTEXPCT))=10,"Not enough entries in %utt5 expected "_UTTEXPCT)
"RTN","utt6",131,0)
 D CHKTF($D(^TMP("%utt5_G",$J,UTTEXPCT+1))=0,"Too many entries in %utt5 expected "_UTTEXPCT)
"RTN","utt6",132,0)
 D CHKTF($O(^TMP("%utt5_G",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5Z_G",1,""))_"' should be 'STARTUP'")
"RTN","utt6",133,0)
 D CHKTF($O(^TMP("%utt5_G",$J,UTTEXPCT,""))="SHUTDOWN","Incorrect function for entry "_UTTEXPCT_", '"_$O(^TMP("%utt5_G",$J,UTTEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",134,0)
 Q
"RTN","utt6",135,0)
 ;
"RTN","utt6",136,0)
CHKTF(VALUE,MESSAGE) ;
"RTN","utt6",137,0)
 D CHKTF^%ut($G(VALUE),$G(MESSAGE))
"RTN","utt6",138,0)
 Q
"RTN","utt6",139,0)
 ;
"RTN","utt6",140,0)
XTENT ;
"RTN","utt6",141,0)
 ;;CHKCMDLN;check command line processing of %utt5
"RTN","utt6",142,0)
 ;;CHKGUI;check GUI processing of %utt5
"RTN","utt6",143,0)
 ;;CKGUISET;check list of tests returned by GUISET
"RTN","utt6",144,0)
 ;;NEWSTYLE;test return of valid new style or @TEST indicators
"RTN","utt7")
0^11^B45754056
"RTN","utt7",1,0)
%utt7 ;JLI/JIVEY@JIVEYSOFT.COM - Unit tests for MUnit !TEST functionality ;04/26/17  21:41
"RTN","utt7",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","utt7",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt7",4,0)
 ; Original routine authored by Joel L. Ivey 04/2017
"RTN","utt7",5,0)
 ;
"RTN","utt7",6,0)
 ; This routine is a copy of %utt1 modified by changing tag T1 to !TEST instead of @Test and adding !TEST to tag T5 to test
"RTN","utt7",7,0)
 ; the handling of !TEST functionality, so that only only those tags are run while tags marked @TEST or under XTENT are ignored
"RTN","utt7",8,0)
 ;
"RTN","utt7",9,0)
 W !,"Running tests in VERBOSE mode"
"RTN","utt7",10,0)
 N X R !,"ENTER RETURN TO CONTINUE: ",X:3
"RTN","utt7",11,0)
 D EN^%ut($T(+0),3) ; Run tests here.
"RTN","utt7",12,0)
 I $G(^TMP("%ut",$J,"UTVALS"))'="7^2^5^2^0" W !!,"The test of !TEST failed, since expected results were:",!,"Ran 7 Routines, 2 Entry Tags",!,"Checked 5 tests, with 2 failures and encountered 0 errors."
"RTN","utt7",13,0)
 Q
"RTN","utt7",14,0)
 ;
"RTN","utt7",15,0)
VERBOSE(VERBSITY) ;
"RTN","utt7",16,0)
 I (+$G(VERBSITY)<1)!($G(VERBSITY)>3) N VERBSITY S VERBSITY=3
"RTN","utt7",17,0)
 W !!,"Running tests in VERBOSE mode with "_$S(VERBSITY=1:"no timing",VERBSITY=2:"whole millisecond timing",3:"fractional millisecond timing"),!
"RTN","utt7",18,0)
 D EN^%ut($T(+0),VERBSITY) ; Run tests here, be verbose.
"RTN","utt7",19,0)
 QUIT
"RTN","utt7",20,0)
 ;
"RTN","utt7",21,0)
STARTUP ; M-Unit Start-Up - This runs before anything else.
"RTN","utt7",22,0)
 ; ZEXCEPT: KBANCOUNT - created here, removed in SHUTDOWN
"RTN","utt7",23,0)
 S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt7",24,0)
 S KBANCOUNT=1
"RTN","utt7",25,0)
 QUIT
"RTN","utt7",26,0)
 ;
"RTN","utt7",27,0)
SHUTDOWN ; M-Unit Shutdown - This runs after everything else is done.
"RTN","utt7",28,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed here
"RTN","utt7",29,0)
 K ^TMP($J,"%ut","STARTUP")
"RTN","utt7",30,0)
 K KBANCOUNT
"RTN","utt7",31,0)
 QUIT
"RTN","utt7",32,0)
 ;
"RTN","utt7",33,0)
 ;
"RTN","utt7",34,0)
 ;
"RTN","utt7",35,0)
SETUP ; This runs before every test.
"RTN","utt7",36,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt7",37,0)
 S KBANCOUNT=KBANCOUNT+1
"RTN","utt7",38,0)
 QUIT
"RTN","utt7",39,0)
 ;
"RTN","utt7",40,0)
TEARDOWN ; This runs after every test
"RTN","utt7",41,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt7",42,0)
 S KBANCOUNT=KBANCOUNT-1
"RTN","utt7",43,0)
 QUIT
"RTN","utt7",44,0)
 ;
"RTN","utt7",45,0)
 ;
"RTN","utt7",46,0)
 ;
"RTN","utt7",47,0)
T1 ; !TEST - Make sure Start-up Ran
"RTN","utt7",48,0)
 D CHKTF($D(^TMP($J,"%ut","STARTUP")),"Start-up node on ^TMP must exist")
"RTN","utt7",49,0)
 QUIT
"RTN","utt7",50,0)
 ;
"RTN","utt7",51,0)
T2 ; @TEST - Make sure Set-up runs
"RTN","utt7",52,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt7",53,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not incremented properly at SETUP")
"RTN","utt7",54,0)
 QUIT
"RTN","utt7",55,0)
 ;
"RTN","utt7",56,0)
T3 ; @TEST - Make sure Teardown runs
"RTN","utt7",57,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt7",58,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not decremented properly at TEARDOWN")
"RTN","utt7",59,0)
 QUIT
"RTN","utt7",60,0)
 ;
"RTN","utt7",61,0)
T4 ; Specified in XTMTAG
"RTN","utt7",62,0)
 ; 140731 JLI - note that this will fail when run from the GUI runner, since it calls each tag separately
"RTN","utt7",63,0)
 ; ZEXCEPT: %utETRY - newed and created in EN1^%ut
"RTN","utt7",64,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT^%ut
"RTN","utt7",65,0)
 I $G(%utGUI) D CHKEQ(%utETRY,"T4","T4 should be the value for %utETRY in the GUI Runner")
"RTN","utt7",66,0)
 I '$G(%utGUI) D CHKEQ(%utETRY(4),"T4","T4 should be the collected as the fourth entry in %utETRY")
"RTN","utt7",67,0)
 QUIT
"RTN","utt7",68,0)
 ;
"RTN","utt7",69,0)
T5 ; !test  - ditto
"RTN","utt7",70,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt7",71,0)
 D CHKTF(0,"This is an intentional failure")
"RTN","utt7",72,0)
 D CHKEQ(%ut("FAIL"),1,"By this point, we should have failed one test")
"RTN","utt7",73,0)
 D FAIL^%ut("Intentionally throwing a failure")
"RTN","utt7",74,0)
 D CHKEQ(%ut("FAIL"),2,"By this point, we should have failed two tests")
"RTN","utt7",75,0)
 ; S %ut("FAIL")=0 ; Okay... Boy's and Girls... as the developer I can do that.
"RTN","utt7",76,0)
 QUIT
"RTN","utt7",77,0)
 ;
"RTN","utt7",78,0)
T6 ; ditto
"RTN","utt7",79,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt7",80,0)
 N TESTCOUNT S TESTCOUNT=%ut("CHK")
"RTN","utt7",81,0)
 D SUCCEED^%ut
"RTN","utt7",82,0)
 D SUCCEED^%ut
"RTN","utt7",83,0)
 D CHKEQ(%ut("CHK"),TESTCOUNT+2,"Succeed should increment the number of tests")
"RTN","utt7",84,0)
 QUIT
"RTN","utt7",85,0)
 ;
"RTN","utt7",86,0)
T7 ; Make sure we write to principal even though we are on another device
"RTN","utt7",87,0)
 ; This is a rather difficult test to carry out for GT.M and Cache...
"RTN","utt7",88,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt7",89,0)
 N D
"RTN","utt7",90,0)
 I $$GETSYS^%ut()=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt7",91,0)
 I $$GETSYS^%ut()=0 D  ; All Cache
"RTN","utt7",92,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt7",93,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt7",94,0)
 I $$GETSYS^%ut()=0 O D:"NWS" ; Cache new file
"RTN","utt7",95,0)
 I $$GETSYS^%ut()=47 O D:(newversion) ; GT.M new file
"RTN","utt7",96,0)
 U D
"RTN","utt7",97,0)
 WRITE "HELLO",!
"RTN","utt7",98,0)
 WRITE "HELLO",!
"RTN","utt7",99,0)
 C D
"RTN","utt7",100,0)
 ;
"RTN","utt7",101,0)
 ; Now open back the file, and read the hello, but open in read only so
"RTN","utt7",102,0)
 ; M-Unit will error out if it will write something out there.
"RTN","utt7",103,0)
 ;
"RTN","utt7",104,0)
 I $$GETSYS^%ut()=0 O D:"R"
"RTN","utt7",105,0)
 I $$GETSYS^%ut()=47 O D:(readonly)
"RTN","utt7",106,0)
 U D
"RTN","utt7",107,0)
 N X READ X:1
"RTN","utt7",108,0)
 D CHKTF(X="HELLO")  ; This should write to the screen the dot not to the file.
"RTN","utt7",109,0)
 D CHKTF(($$LO($IO)=$$LO(D)),"IO device didn't get reset back")       ; $$LO is b/c of a bug in Cache/Windows. $IO is not the same cas D.
"RTN","utt7",110,0)
 I $$GETSYS^%ut()=0 C D:"D"
"RTN","utt7",111,0)
 I $$GETSYS^%ut()=47 C D:(delete)
"RTN","utt7",112,0)
 U $P
"RTN","utt7",113,0)
 S IO=$IO
"RTN","utt7",114,0)
 QUIT
"RTN","utt7",115,0)
 ;
"RTN","utt7",116,0)
 ; At the moment T8^%utt1 throws a fail, with no message
"RTN","utt7",117,0)
 ; in the GUI runner.  For some reason, both X and Y
"RTN","utt7",118,0)
 ; variables are returned as null strings, while in the
"RTN","utt7",119,0)
 ; command line runner, Y has a value containing the
"RTN","utt7",120,0)
 ; word being sought
"RTN","utt7",121,0)
 ;
"RTN","utt7",122,0)
T8 ; If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt7",123,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt7",124,0)
 ; ZEXCEPT: %utGUI - if present, defined and killed elsewhere
"RTN","utt7",125,0)
 I $D(%utGUI) Q  ; GUI doesn't run verbose
"RTN","utt7",126,0)
 N D
"RTN","utt7",127,0)
 I $$GETSYS^%ut()=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt7",128,0)
 I $$GETSYS^%ut()=0 D  ; All Cache
"RTN","utt7",129,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt7",130,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt7",131,0)
 I $$GETSYS^%ut()=0 O D:"NWS" ; Cache new file
"RTN","utt7",132,0)
 I $$GETSYS^%ut()=47 O D:(newversion) ; GT.M new file
"RTN","utt7",133,0)
 S IO=D
"RTN","utt7",134,0)
 U D
"RTN","utt7",135,0)
 D ^%utt4 ; Run some Unit Tests
"RTN","utt7",136,0)
 C D
"RTN","utt7",137,0)
 I $$GETSYS^%ut()=0 O D:"R" ; Cache read only
"RTN","utt7",138,0)
 I $$GETSYS^%ut()=47 O D:(readonly) ; GT.M read only
"RTN","utt7",139,0)
 U D
"RTN","utt7",140,0)
 N X,Y,Z,Z1,Z2,Z3,Z4 R X:1,Y:1,Z:1,Z1:1,Z2:1,Z3:1,Z4:1
"RTN","utt7",141,0)
 I $$GETSYS^%ut()=0 C D:"D"
"RTN","utt7",142,0)
 I $$GETSYS^%ut()=47 C D:(delete)
"RTN","utt7",143,0)
 D CHKTF(Z1["MAIN","Write to system during test didn't work")
"RTN","utt7",144,0)
 S IO=$P,IO(0)=IO
"RTN","utt7",145,0)
 QUIT
"RTN","utt7",146,0)
 ;
"RTN","utt7",147,0)
COVRPTGL ;
"RTN","utt7",148,0)
 N GL1,GL2,GL3,GL4
"RTN","utt7",149,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","utt7",150,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","utt7",151,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","utt7",152,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","utt7",153,0)
 D SETGLOBS^%uttcovr(GL1,GL2)
"RTN","utt7",154,0)
 D COVRPTGL^%utcover(GL1,GL2,GL3,GL4)
"RTN","utt7",155,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES")),"0/9","Wrong number of lines covered f>>or ACTLINES")
"RTN","utt7",156,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES",9))," QUIT CNT","Wrong result for last l>>ine not covered for ACTLINES")
"RTN","utt7",157,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST")),"8/10","Wrong number of lines covered >>for CHEKTEST")
"RTN","utt7",158,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST",39))," . Q","Wrong result for last line >>not covered for CHEKTEST")
"RTN","utt7",159,0)
 K @GL1,@GL2,@GL3,@GL4
"RTN","utt7",160,0)
 Q
"RTN","utt7",161,0)
 ;
"RTN","utt7",162,0)
LO(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
"RTN","utt7",163,0)
 ; Shortcut methods for M-Unit
"RTN","utt7",164,0)
CHKTF(X,Y) ;
"RTN","utt7",165,0)
 D CHKTF^%ut(X,$G(Y))
"RTN","utt7",166,0)
 QUIT
"RTN","utt7",167,0)
 ;
"RTN","utt7",168,0)
CHKEQ(A,B,M) ;
"RTN","utt7",169,0)
 D CHKEQ^%ut(A,B,$G(M))
"RTN","utt7",170,0)
 QUIT
"RTN","utt7",171,0)
 ;
"RTN","utt7",172,0)
XTENT ; Entry points
"RTN","utt7",173,0)
 ;;T4;Entry point using XTMENT
"RTN","utt7",174,0)
 ;;T5;Error count check
"RTN","utt7",175,0)
 ;;T6;Succeed Entry Point
"RTN","utt7",176,0)
 ;;T7;Make sure we write to principal even though we are on another device
"RTN","utt7",177,0)
 ;;T8;If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt7",178,0)
 ;;COVRPTGL;coverage report returning global
"RTN","utt7",179,0)
 ;
"RTN","utt7",180,0)
XTROU ; Routines containing additional tests
"RTN","utt7",181,0)
 ;;%utt1;
"RTN","utt7",182,0)
 ;;%utt2; old %utNITU
"RTN","utt7",183,0)
 ;;%utt4; old %utNITW
"RTN","utt7",184,0)
 ;;%utt5;
"RTN","utt7",185,0)
 ;;%utt6;
"RTN","utt7",186,0)
 ;;%uttcovr;coverage related tests
"RTN","uttcovr")
0^10^B188096777
"RTN","uttcovr",1,0)
%uttcovr ;JIVEYSOFT/JLI - runs coverage tests on %ut and %ut1 routines via unit tests ;06/16/17  15:37
"RTN","uttcovr",2,0)
 ;;1.5;MASH UTILITIES;;Jul 8, 2017;Build 13
"RTN","uttcovr",3,0)
 ; Submitted to OSEHRA Jul 8, 2017 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","uttcovr",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015
"RTN","uttcovr",5,0)
 ; Modified by Joel L. Ivey 02/2016-03/2016
"RTN","uttcovr",6,0)
 ;
"RTN","uttcovr",7,0)
 ;
"RTN","uttcovr",8,0)
 ; ZEXCEPT: DTIME - if present the value is Kernel timeout for reads
"RTN","uttcovr",9,0)
 N RUNCODE,XCLUDE
"RTN","uttcovr",10,0)
 ;
"RTN","uttcovr",11,0)
 ; Have it run the following entry points or, if no ^, call EN^%ut with routine name
"RTN","uttcovr",12,0)
 S RUNCODE(1)="^%utt1,%utt1,VERBOSE^%utt1(3),^%utt6,VERBOSE^%utt6,VERBOSE3^%utt6,VERBOSE2^%utt6,%uttcovr,^%ut,^%ut1,^%utcover,^%utt7,VERBOSE^%utt7"
"RTN","uttcovr",13,0)
 S RUNCODE("ENTRY^%uttcovr")=""
"RTN","uttcovr",14,0)
 ; Have the analysis EXCLUDE the following routines from coverage - unit test routines
"RTN","uttcovr",15,0)
 S XCLUDE(1)="%utt1,%utt2,%utt3,%utt4,%utt5,%utt6,%uttcovr,%utt7"
"RTN","uttcovr",16,0)
 S XCLUDE(2)="%utf2hex" ; a GT.M system file, although it wasn't showing up anyway
"RTN","uttcovr",17,0)
 M ^TMP("%uttcovr",$J,"XCLUDE")=XCLUDE
"RTN","uttcovr",18,0)
 D COVERAGE^%ut("%ut*",.RUNCODE,.XCLUDE,3)
"RTN","uttcovr",19,0)
 Q
"RTN","uttcovr",20,0)
 ;
"RTN","uttcovr",21,0)
ENTRY ;
"RTN","uttcovr",22,0)
 K ^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",23,0)
 M ^TMP("ENTRY^%uttcovr",$J,"VALS")=^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",24,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",25,0)
 ; these tests run outside of unit tests to handle CHKLEAKS calls not in unit tests
"RTN","uttcovr",26,0)
 ; they need data set, so they are called in here
"RTN","uttcovr",27,0)
 ; LEAKSOK ;
"RTN","uttcovr",28,0)
 N CODE,LOCATN,MYVALS,X,I
"RTN","uttcovr",29,0)
 S CODE="S X=4",LOCATN="LEAKSOK TEST",MYVALS("X")=""
"RTN","uttcovr",30,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find no leaks
"RTN","uttcovr",31,0)
 ; LEAKSBAD ;
"RTN","uttcovr",32,0)
 N CODE,LOCATN,MYVALS,X
"RTN","uttcovr",33,0)
 S CODE="S X=4",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED"
"RTN","uttcovr",34,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find X since it isn't indicated
"RTN","uttcovr",35,0)
 ; try to run coverage
"RTN","uttcovr",36,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COV^%ut FOR %utt5 at 3",!!!
"RTN","uttcovr",37,0)
 D COV^%ut("%ut1","D EN^%ut(""%utt5"")",3)
"RTN","uttcovr",38,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COV^%ut FOR %utt5 at -1",!!!
"RTN","uttcovr",39,0)
 D COV^%ut("%ut1","D EN^%ut(""%utt5"")",-1)
"RTN","uttcovr",40,0)
 N RUNCODE S RUNCODE(1)="^%utt4,^%ut"
"RTN","uttcovr",41,0)
 N XCLUDE M XCLUDE=^TMP("%uttcovr",$J,"XCLUDE")
"RTN","uttcovr",42,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO MULTAPIS for %utt4 and %ut",!!!
"RTN","uttcovr",43,0)
 D MULTAPIS^%ut(.RUNCODE)
"RTN","uttcovr",44,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COVERAGE for %utt4 and %ut at 3",!!!
"RTN","uttcovr",45,0)
 D COVERAGE^%ut("%ut*",.RUNCODE,.XCLUDE,3)
"RTN","uttcovr",46,0)
 N GLT S GLT=$NA(^TMP("%uttcovr-text",$J)) K @GLT
"RTN","uttcovr",47,0)
 W !,"xxxxxxxxxxxxxxxxxxxx LISTING DATA VIA LIST",!!!
"RTN","uttcovr",48,0)
 D LIST^%utcover(.XCLUDE,3,GLT) ; get coverage for listing and trimdata in %utcover
"RTN","uttcovr",49,0)
 F I=1:1 Q:'$D(@GLT@(I))  W !,@GLT@(I)
"RTN","uttcovr",50,0)
 K @GLT
"RTN","uttcovr",51,0)
 ; restore unit test totals from before entry
"RTN","uttcovr",52,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",53,0)
 M ^TMP("%ut",$J,"UTVALS")=^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",54,0)
 K ^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",55,0)
 W !,"xxxxxxxxxxxxxxxxxxxx Finished in ENTRY^%uttcovr",!!!
"RTN","uttcovr",56,0)
 Q
"RTN","uttcovr",57,0)
 ;
"RTN","uttcovr",58,0)
RTNANAL ; @TEST - routine analysis
"RTN","uttcovr",59,0)
 N ROUS,GLB
"RTN","uttcovr",60,0)
 S ROUS("%utt4")=""
"RTN","uttcovr",61,0)
 S GLB=$NA(^TMP("%uttcovr-rtnanal",$J)) K @GLB
"RTN","uttcovr",62,0)
 D RTNANAL^%ut1(.ROUS,GLB)
"RTN","uttcovr",63,0)
 D CHKTF($D(@GLB@("%utt4","MAIN"))>1,"Not enough 'MAIN' nodes found")
"RTN","uttcovr",64,0)
 D CHKTF($G(@GLB@("%utt4","MAIN",4))["D COV^%ut(""%utt3"",""D EN^%ut(""""%utt3"""",1)"",-1)","Incorrect data for line 2 in MAIN")
"RTN","uttcovr",65,0)
 D CHKTF($G(@GLB@("%utt4","MAIN",10))=" QUIT","Final QUIT not on expected line")
"RTN","uttcovr",66,0)
 K @GLB
"RTN","uttcovr",67,0)
 Q
"RTN","uttcovr",68,0)
 ;
"RTN","uttcovr",69,0)
COVCOV ; @TEST - check COVCOV - remove seen lines
"RTN","uttcovr",70,0)
 N C,R
"RTN","uttcovr",71,0)
 S C=$NA(^TMP("%uttcovr_C",$J))
"RTN","uttcovr",72,0)
 S R=$NA(^TMP("%uttcovr_R",$J))
"RTN","uttcovr",73,0)
 S @C@("ROU1")=""
"RTN","uttcovr",74,0)
 S @C@("ROU2")="",@R@("ROU2")=""
"RTN","uttcovr",75,0)
 S @C@("ROU2","TAG1")="",@R@("ROU2","TAG1")=""
"RTN","uttcovr",76,0)
 S @C@("ROU2","TAG1",1)="AAA"
"RTN","uttcovr",77,0)
 S @C@("ROU2","TAG1",2)="AAA",@R@("ROU2","TAG1",2)="AAA"
"RTN","uttcovr",78,0)
 S @C@("ROU2","TAG1",3)="ABB",@R@("ROU2","TAG1",3)="ABB"
"RTN","uttcovr",79,0)
 S @C@("ROU2","TAG2",6)="ACC"
"RTN","uttcovr",80,0)
 S @C@("ROU2","TAG2",7)="ADD",@R@("ROU2","TAG2",7)="ADD"
"RTN","uttcovr",81,0)
 S @C@("ROU3","TAG1",2)="BAA",@R@("ROU3","TAG1",2)="BAA"
"RTN","uttcovr",82,0)
 S @C@("ROU3","TAG1",3)="CAA"
"RTN","uttcovr",83,0)
 S @C@("ROU3","TAG1",4)="DAA"
"RTN","uttcovr",84,0)
 S @C@("ROU3","TAG1",5)="EAA",@R@("ROU3","TAG1",5)="EAA"
"RTN","uttcovr",85,0)
 S @C@("ROU3","TAG1",6)="FAA",@R@("ROU3","TAG1",6)="FAA"
"RTN","uttcovr",86,0)
 D COVCOV^%ut1(C,R)
"RTN","uttcovr",87,0)
 D CHKTF($D(@C@("ROU2","TAG1",1)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",88,0)
 D CHKTF('$D(@C@("ROU2","TAG1",2)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",89,0)
 D CHKTF($D(@C@("ROU2","TAG2",6)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",90,0)
 D CHKTF('$D(@C@("ROU2","TAG2",7)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",91,0)
 D CHKTF($D(@C@("ROU3","TAG1",4)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",92,0)
 D CHKTF('$D(@C@("ROU3","TAG1",5)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",93,0)
 K @C,@R
"RTN","uttcovr",94,0)
 Q
"RTN","uttcovr",95,0)
 ;
"RTN","uttcovr",96,0)
COVRPT  ; @TEST
"RTN","uttcovr",97,0)
 N GL1,GL2,GL3,GL4,VRBOSITY,GL5
"RTN","uttcovr",98,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","uttcovr",99,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","uttcovr",100,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","uttcovr",101,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","uttcovr",102,0)
 S GL5=$NA(^TMP("%ut1-covrpt",$J)) K @GL5
"RTN","uttcovr",103,0)
 D SETGLOBS(GL1,GL2)
"RTN","uttcovr",104,0)
 S VRBOSITY=1
"RTN","uttcovr",105,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",106,0)
 D CHKEQ("COVERAGE PERCENTAGE: 42.11",$G(@GL5@(5)),"Verbosity 1 - not expected percentage value")
"RTN","uttcovr",107,0)
 D CHKEQ("  %ut1            42.11%  8 out of 19",$G(@GL5@(9)),"Verbosity 1 - not expected value for line 9")
"RTN","uttcovr",108,0)
 D CHKTF('$D(@GL5@(10)),"Verbosity 1 - unexpected data in 10th line")
"RTN","uttcovr",109,0)
 ;
"RTN","uttcovr",110,0)
 S VRBOSITY=2
"RTN","uttcovr",111,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",112,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL5@(10)),"Verbosity 2 - not expected value for 10th line")
"RTN","uttcovr",113,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL5@(11)),"Verbosity 2 - not expected value for 11th line")
"RTN","uttcovr",114,0)
 D CHKTF('$D(@GL5@(12)),"Verbosity 2 - unexpected data for 12th line")
"RTN","uttcovr",115,0)
 ;
"RTN","uttcovr",116,0)
 S VRBOSITY=3
"RTN","uttcovr",117,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",118,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL5@(10)),"Verbosity 3 - unexpected value for line 10")
"RTN","uttcovr",119,0)
 D CHKEQ("ACTLINES+9:  QUIT CNT",$G(@GL5@(19)),"Verbosity 3 - unexpected value for line 19")
"RTN","uttcovr",120,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL5@(20)),"Verbosity 3 - unexpected value for line 20")
"RTN","uttcovr",121,0)
 D CHKEQ("CHEKTEST+39:  . Q",$G(@GL5@(22)),"Verbosity 3 - unexpected value for line 22")
"RTN","uttcovr",122,0)
 D CHKTF('$D(@GL5@(23)),"Verbosity 3 - unexpected line 23")
"RTN","uttcovr",123,0)
 K @GL1,@GL2,@GL3,@GL4,@GL5
"RTN","uttcovr",124,0)
 Q
"RTN","uttcovr",125,0)
 ;
"RTN","uttcovr",126,0)
COVRPTLS ; @TEST - coverage report returning text in global
"RTN","uttcovr",127,0)
 N GL1,GL2,GL3,GL4,VRBOSITY
"RTN","uttcovr",128,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","uttcovr",129,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","uttcovr",130,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","uttcovr",131,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","uttcovr",132,0)
 D SETGLOBS(GL1,GL2)
"RTN","uttcovr",133,0)
 S VRBOSITY=1
"RTN","uttcovr",134,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",135,0)
 D CHKEQ("COVERAGE PERCENTAGE: 42.11",$G(@GL4@(5)),"Verbosity 1 - not expected percentage value")
"RTN","uttcovr",136,0)
 D CHKEQ("  %ut1            42.11%  8 out of 19",$G(@GL4@(9)),"Verbosity 1 - not expected value for line 9")
"RTN","uttcovr",137,0)
 D CHKTF('$D(@GL4@(10)),"Verbosity 1 - unexpected data in 10th line")
"RTN","uttcovr",138,0)
 K @GL4
"RTN","uttcovr",139,0)
 ;
"RTN","uttcovr",140,0)
 S VRBOSITY=2
"RTN","uttcovr",141,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",142,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL4@(10)),"Verbosity 2 - not expected value for 10th line")
"RTN","uttcovr",143,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL4@(11)),"Verbosity 2 - not expected value for 11th line")
"RTN","uttcovr",144,0)
 D CHKTF('$D(@GL4@(12)),"Verbosity 2 - unexpected data for 12th line")
"RTN","uttcovr",145,0)
 K @GL4
"RTN","uttcovr",146,0)
 ;
"RTN","uttcovr",147,0)
 S VRBOSITY=3
"RTN","uttcovr",148,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",149,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL4@(10)),"Verbosity 3 - unexpected value for line 10")
"RTN","uttcovr",150,0)
 D CHKEQ("ACTLINES+9:  QUIT CNT",$G(@GL4@(19)),"Verbosity 3 - unexpected value for line 19")
"RTN","uttcovr",151,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL4@(20)),"Verbosity 3 - unexpected value for line 20")
"RTN","uttcovr",152,0)
 D CHKEQ("CHEKTEST+39:  . Q",$G(@GL4@(22)),"Verbosity 3 - unexpected value for line 22")
"RTN","uttcovr",153,0)
 D CHKTF('$D(@GL4@(23)),"Verbosity 3 - unexpected line 23")
"RTN","uttcovr",154,0)
 ;
"RTN","uttcovr",155,0)
 K @GL1,@GL2,@GL3,@GL4
"RTN","uttcovr",156,0)
 Q
"RTN","uttcovr",157,0)
 ;
"RTN","uttcovr",158,0)
TRIMDATA ; @TEST - TRIMDATA in %utcover
"RTN","uttcovr",159,0)
 N GL1,XCLUD
"RTN","uttcovr",160,0)
 S GL1=$NA(^TMP("%uttcovr-trimdata",$J)) K @GL1
"RTN","uttcovr",161,0)
 S @GL1@("GOOD",1)="1"
"RTN","uttcovr",162,0)
 S @GL1@("BAD",1)="1"
"RTN","uttcovr",163,0)
 S XCLUD("BAD")=""
"RTN","uttcovr",164,0)
 D TRIMDATA^%utcover(.XCLUD,GL1)
"RTN","uttcovr",165,0)
 D CHKTF($D(@GL1@("GOOD")),"GOOD ENTRY WAS REMOVED")
"RTN","uttcovr",166,0)
 D CHKTF('$D(@GL1@("BAD")),"ENTRY WAS NOT TRIMMED")
"RTN","uttcovr",167,0)
 K @GL1,XCLUD
"RTN","uttcovr",168,0)
 Q
"RTN","uttcovr",169,0)
 ;
"RTN","uttcovr",170,0)
LIST ; @TEST - LIST in %utcover
"RTN","uttcovr",171,0)
 N GL1,GLT S GL1=$NA(^TMP("%uttcovr-list",$J)),GLT=$NA(^TMP("%uttcovr-text",$J))
"RTN","uttcovr",172,0)
 S @GL1@("%ut1")="89/160"
"RTN","uttcovr",173,0)
 S @GL1@("%ut1","%ut1")="2/2"
"RTN","uttcovr",174,0)
 S @GL1@("%ut1","ACTLINES")="0/8"
"RTN","uttcovr",175,0)
 S @GL1@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",176,0)
 S @GL1@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",177,0)
 S @GL1@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",178,0)
 S @GL1@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",179,0)
 S @GL1@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",180,0)
 S @GL1@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",181,0)
 S @GL1@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",182,0)
 S @GL1@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",183,0)
 S @GL1@("%ut1","CHECKTAG")="11/11"
"RTN","uttcovr",184,0)
 S @GL1@("%ut1","CHEKTEST")="10/10"
"RTN","uttcovr",185,0)
 N XCLUD S XCLUD("%utt1")=""
"RTN","uttcovr",186,0)
 D LIST^%utcover(.XCLUD,1,GLT,GL1)
"RTN","uttcovr",187,0)
 D CHKEQ("Routine %ut1      (55.63%)   89 out of 160 lines covered",$G(@GLT@(3)),"Verbosity 1 - Unexpected text for line 3")
"RTN","uttcovr",188,0)
 D CHKEQ("Overall Analysis 89 out of 160 lines covered (55% coverage)",$G(@GLT@(6)),"Verbosity 1 - unexpected text for line 6")
"RTN","uttcovr",189,0)
 D CHKTF('$D(@GLT@(7)),"Verbosity 1 - Unexpected line 7 present")
"RTN","uttcovr",190,0)
 K @GLT
"RTN","uttcovr",191,0)
 ;
"RTN","uttcovr",192,0)
 D LIST^%utcover(.XCLUD,2,GLT,GL1)
"RTN","uttcovr",193,0)
 D CHKEQ("  - Summary",$G(@GLT@(4)),"Verbosity 2 - unexpected text at line 4")
"RTN","uttcovr",194,0)
 D CHKEQ(" Tag ACTLINES^%ut1          (0.00%)   0 out of 8 lines covered",$G(@GLT@(6)),"Verbosity 2 - unexpected text at line 6")
"RTN","uttcovr",195,0)
 D CHKEQ(" Tag CHEKTEST^%ut1        (100.00%)   10 out of 10 lines covered",$G(@GLT@(8)),"Verbosity 2 - unexpected text at line 8")
"RTN","uttcovr",196,0)
 D CHKTF($D(@GLT@(14)),"Verbosity 2 - expected line at line 14")
"RTN","uttcovr",197,0)
 D CHKTF('$D(@GLT@(15)),"Verbosity 2 - unexpected line at line 15")
"RTN","uttcovr",198,0)
 K @GLT
"RTN","uttcovr",199,0)
 ;
"RTN","uttcovr",200,0)
 D LIST^%utcover(.XCLUD,3,GLT,GL1)
"RTN","uttcovr",201,0)
 D CHKEQ(" Tag %ut1^%ut1            (100.00%)   2 out of 2 lines covered",$G(@GLT@(5)),"Verbosity 3 - Incorrect text at line 5")
"RTN","uttcovr",202,0)
 D CHKEQ("     ACTLINES+9   QUIT CNT",$G(@GLT@(15)),"Verbosity 3 - incorrect line 15")
"RTN","uttcovr",203,0)
 D CHKTF($D(@GLT@(31)),"Verbosity 3 - expected data in line 31")
"RTN","uttcovr",204,0)
 D CHKTF('$D(@GLT@(32)),"Verbosity 3 - did not expect a line 32")
"RTN","uttcovr",205,0)
 ;
"RTN","uttcovr",206,0)
 K @GL1,@GLT
"RTN","uttcovr",207,0)
 Q
"RTN","uttcovr",208,0)
 ;
"RTN","uttcovr",209,0)
SETGLOBS(GL1,GL2) ;
"RTN","uttcovr",210,0)
 S @GL1@("%ut1","ACTLINES")="ACTLINES"
"RTN","uttcovr",211,0)
 S @GL1@("%ut1","ACTLINES",0)="ACTLINES(GL) ; [Private] $$ ; Count active lines"
"RTN","uttcovr",212,0)
 S @GL1@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",213,0)
 S @GL1@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",214,0)
 S @GL1@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",215,0)
 S @GL1@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",216,0)
 S @GL1@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",217,0)
 S @GL1@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",218,0)
 S @GL1@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",219,0)
 S @GL1@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",220,0)
 S @GL1@("%ut1","CHEKTEST")="CHEKTEST"
"RTN","uttcovr",221,0)
 S @GL1@("%ut1","CHEKTEST",0)="CHEKTEST(%utROU,%ut,%utUETRY) ; Collect Test list."
"RTN","uttcovr",222,0)
 S @GL1@("%ut1","CHEKTEST",13)=" N I,LIST"
"RTN","uttcovr",223,0)
 S @GL1@("%ut1","CHEKTEST",14)=" S I=$L($T(@(U_%utROU))) I I<0 Q ""-1^Invalid Routine Name"""
"RTN","uttcovr",224,0)
 S @GL1@("%ut1","CHEKTEST",31)=" D NEWSTYLE(.LIST,%utROU)"
"RTN","uttcovr",225,0)
 S @GL1@("%ut1","CHEKTEST",32)=" F I=1:1:LIST S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(LIST(I),U),%utUETRY(%ut(""ENTN""),""NAME"")=$P(LIST(I),U,2,99)"
"RTN","uttcovr",226,0)
 S @GL1@("%ut1","CHEKTEST",37)=" N %utUI F %utUI=1:1 S %ut(""ELIN"")=$T(@(""XTENT+""_%utUI_""^""_%utROU)) Q:$P(%ut(""ELIN""),"";"",3)=""""  D"
"RTN","uttcovr",227,0)
 S @GL1@("%ut1","CHEKTEST",38)=" . S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(%ut(""ELIN""),"";"",3),%utUETRY(%ut(""ENTN""),""NAME"")=$P(%ut(""ELIN""),"";"",4)"
"RTN","uttcovr",228,0)
 S @GL1@("%ut1","CHEKTEST",39)=" . Q"
"RTN","uttcovr",229,0)
 S @GL1@("%ut1","CHEKTEST",41)=" QUIT"
"RTN","uttcovr",230,0)
 S @GL1@("%ut1","CHEKTEST",9)=" S %ut(""ENTN"")=0 ; Number of test, sub to %utUETRY."
"RTN","uttcovr",231,0)
 S @GL2@("%ut1","ACTLINES")="ACTLINES"
"RTN","uttcovr",232,0)
 S @GL2@("%ut1","ACTLINES",0)="ACTLINES(GL) ; [Private] $$ ; Count active lines"
"RTN","uttcovr",233,0)
 S @GL2@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",234,0)
 S @GL2@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",235,0)
 S @GL2@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",236,0)
 S @GL2@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",237,0)
 S @GL2@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",238,0)
 S @GL2@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",239,0)
 S @GL2@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",240,0)
 S @GL2@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",241,0)
 S @GL2@("%ut1","CHEKTEST")="CHEKTEST"
"RTN","uttcovr",242,0)
 S @GL2@("%ut1","CHEKTEST",38)=" . S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(%ut(""ELIN""),"";"",3),%utUETRY(%ut(""ENTN""),""NAME"")=$P(%ut(""ELIN""),"";"",4)"
"RTN","uttcovr",243,0)
 S @GL2@("%ut1","CHEKTEST",39)=" . Q"
"RTN","uttcovr",244,0)
 Q
"RTN","uttcovr",245,0)
 ;
"RTN","uttcovr",246,0)
 ;
"RTN","uttcovr",247,0)
CACHECOV ;@TEST - set up routine for analysis in globals
"RTN","uttcovr",248,0)
 N GLOB,GLOBT
"RTN","uttcovr",249,0)
 S GLOB=$NA(^TMP("%uttcovr1",$J)),GLOBT=$NA(@GLOB@("uttcovr2",$J)) K @GLOB,@GLOBT
"RTN","uttcovr",250,0)
 K ^TMP("%utt4val",$J)
"RTN","uttcovr",251,0)
 D CACHECOV^%ut1(GLOB,GLOBT)
"RTN","uttcovr",252,0)
 D CHKEQ($T(+1^%ut),@GLOB@("%ut",1,0),"BAD FIRST LINE LOADED FOR %ut")
"RTN","uttcovr",253,0)
 D CHKEQ($T(+14^%ut),@GLOBT@("%ut",14,0),"Bad 14th line loaded for %ut")
"RTN","uttcovr",254,0)
 K @GLOB,@GLOBT
"RTN","uttcovr",255,0)
 Q
"RTN","uttcovr",256,0)
 ;
"RTN","uttcovr",257,0)
GETVALS ; no test - primarily calls to Cache classes
"RTN","uttcovr",258,0)
 Q
"RTN","uttcovr",259,0)
 ;
"RTN","uttcovr",260,0)
LINEDATA ; @TEST - convert code line to based on tags and offset, and identify active code lines
"RTN","uttcovr",261,0)
 N CODE,LINE,OFFSET,TAG
"RTN","uttcovr",262,0)
 S LINE="TEST1 ; COMMENT ON TAG",TAG="",OFFSET=0
"RTN","uttcovr",263,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",264,0)
 D CHKEQ(0,CODE,"Tag with comment identified as active code")
"RTN","uttcovr",265,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1")
"RTN","uttcovr",266,0)
 D CHKEQ(0,OFFSET,"Bad OFFSET returned for TEST1")
"RTN","uttcovr",267,0)
 ;
"RTN","uttcovr",268,0)
 S LINE=" ; COMMENT ONLY"
"RTN","uttcovr",269,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",270,0)
 D CHKEQ(0,CODE,"Comment line identified as active code")
"RTN","uttcovr",271,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1+1")
"RTN","uttcovr",272,0)
 D CHKEQ(1,OFFSET,"Bad OFFSET returned for TEST1+1")
"RTN","uttcovr",273,0)
 ;
"RTN","uttcovr",274,0)
 S LINE=" S X=VALUE"
"RTN","uttcovr",275,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",276,0)
 D CHKEQ(1,CODE,"Code line NOT identified as active code")
"RTN","uttcovr",277,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1+2")
"RTN","uttcovr",278,0)
 D CHKEQ(2,OFFSET,"Bad OFFSET returned for TEST1+2")
"RTN","uttcovr",279,0)
 ;
"RTN","uttcovr",280,0)
 S LINE="TEST2 S X=VALUE"
"RTN","uttcovr",281,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",282,0)
 D CHKEQ(1,CODE,"Tag line with code NOT identified as active code")
"RTN","uttcovr",283,0)
 D CHKEQ("TEST2",TAG,"Bad tag returned for TEST2")
"RTN","uttcovr",284,0)
 D CHKEQ(0,OFFSET,"Bad OFFSET returned for TEST2")
"RTN","uttcovr",285,0)
 ;
"RTN","uttcovr",286,0)
 Q
"RTN","uttcovr",287,0)
 ;
"RTN","uttcovr",288,0)
TOTAGS ;@TEST - convert from lines of code by line number to lines ordered by tag, line from tag, and only not covered
"RTN","uttcovr",289,0)
 N ACTIVE,GLOB,GLOBT,X1,X0
"RTN","uttcovr",290,0)
 S GLOB=$NA(^TMP("%uttcovr",$J)),GLOBT=$NA(@GLOB@("TEST1")) K @GLOB
"RTN","uttcovr",291,0)
 S @GLOBT@(1,0)="LINE1 ; CODE1 LINE1+0 NOT ACTIVE"
"RTN","uttcovr",292,0)
 S @GLOBT@(2,0)=" CODE2 LINE+1 SEEN"
"RTN","uttcovr",293,0)
 S @GLOBT@(2,"C")=2
"RTN","uttcovr",294,0)
 S @GLOBT@(3,0)=" CODE3 LINE1+2 NOT SEEN"
"RTN","uttcovr",295,0)
 S @GLOBT@(4,0)="LINE4 CODE4 LINE4+0 SEEN"
"RTN","uttcovr",296,0)
 S @GLOBT@(4,"C")=5
"RTN","uttcovr",297,0)
 S @GLOBT@(5,0)=" ; CODE5 LINE4+1 NOT ACTIVE"
"RTN","uttcovr",298,0)
 S @GLOBT@(6,0)=" CODE6 LINE4+2 COVERED"
"RTN","uttcovr",299,0)
 S @GLOBT@(6,"C")=2
"RTN","uttcovr",300,0)
 S @GLOBT@(7,0)="LINE7 CODE7 LINE7+0 NOT COVERED"
"RTN","uttcovr",301,0)
 S @GLOBT@(8,0)=" CODE8 LINE7+1 NOT COVERED"
"RTN","uttcovr",302,0)
 S ACTIVE=1
"RTN","uttcovr",303,0)
 D TOTAGS^%ut1(GLOB,ACTIVE)
"RTN","uttcovr",304,0)
 D CHKEQ(1,($D(@GLOBT@("LINE1"))#2),"LINE1 TAG NOT IDENTIFIED")
"RTN","uttcovr",305,0)
 D CHKEQ(1,($D(@GLOBT@("LINE4"))#2),"LINE4 TAG NOT IDENTIFIED")
"RTN","uttcovr",306,0)
 D CHKEQ(1,($D(@GLOBT@("LINE7"))#2),"LINE7 TAG NOT IDENTIFIED")
"RTN","uttcovr",307,0)
 D CHKEQ(0,$D(@GLOBT@("LINE1",0)),"LINE1+0 SHOULD NOT BE INCLUDED - IT IS A COMMENT")
"RTN","uttcovr",308,0)
 D CHKEQ(0,$D(@GLOBT@("LINE1",1)),"LINE1+1 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",309,0)
 D CHKEQ(1,$D(@GLOBT@("LINE1",2)),"LINE1+2 SHOULD BE INCLUDED - IT WAS NOT COVERED")
"RTN","uttcovr",310,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",0)),"LINE4+0 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",311,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",1)),"LINE4+1 SHOULD NOT BE INCLUDED - IT IS A COMMENT")
"RTN","uttcovr",312,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",2)),"LINE4+2 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",313,0)
 D CHKEQ(1,$D(@GLOBT@("LINE7",0)),"LINE7+0 SHOULD BE INCLUDED - IT IS NOT COVERED")
"RTN","uttcovr",314,0)
 D CHKEQ(1,$D(@GLOBT@("LINE7",1)),"LINE7+1 SHOULD BE INCLUDED - IT IS NOT COVERED")
"RTN","uttcovr",315,0)
 K @GLOB,@GLOBT
"RTN","uttcovr",316,0)
 Q
"RTN","uttcovr",317,0)
 ;
"RTN","uttcovr",318,0)
CHKEQ(EXPECTED,SEEN,COMMENT) ;
"RTN","uttcovr",319,0)
 D CHKEQ^%ut(EXPECTED,SEEN,$G(COMMENT))
"RTN","uttcovr",320,0)
 Q
"RTN","uttcovr",321,0)
 ;
"RTN","uttcovr",322,0)
CHKTF(VALUE,COMMENT) ;
"RTN","uttcovr",323,0)
 D CHKTF^%ut(VALUE,$G(COMMENT))
"RTN","uttcovr",324,0)
 Q
"SEC","^DIC",17.9001,17.9001,0,"AUDIT")
@
"SEC","^DIC",17.9001,17.9001,0,"DD")
@
"SEC","^DIC",17.9001,17.9001,0,"DEL")
@
"SEC","^DIC",17.9001,17.9001,0,"LAYGO")
@
"SEC","^DIC",17.9001,17.9001,0,"RD")
@
"SEC","^DIC",17.9001,17.9001,0,"WR")
@
"VER")
8.0^22.0
"^DD",17.9001,17.9001,0)
FIELD^^2^3
"^DD",17.9001,17.9001,0,"DT")
3140812
"^DD",17.9001,17.9001,0,"IX","B",17.9001,.01)

"^DD",17.9001,17.9001,0,"NM","MUNIT TEST GROUP")
 
"^DD",17.9001,17.9001,0,"VRPK")
MASH
"^DD",17.9001,17.9001,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",17.9001,17.9001,.01,1,0)
^.1
"^DD",17.9001,17.9001,.01,1,1,0)
17.9001^B
"^DD",17.9001,17.9001,.01,1,1,1)
S ^%ut(17.9001,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.9001,.01,1,1,2)
K ^%ut(17.9001,"B",$E(X,1,30),DA)
"^DD",17.9001,17.9001,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",17.9001,17.9001,1,0)
TEST ROUTINE^17.90011^^1;0
"^DD",17.9001,17.9001,2,0)
DESCRIPTION FOR GROUP^17.90012^^2;0
"^DD",17.9001,17.9001,2,21,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,21,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,21,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,23,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,"DT")
3140812
"^DD",17.9001,17.90011,0)
TEST ROUTINE SUB-FIELD^^.01^1
"^DD",17.9001,17.90011,0,"DT")
3140731
"^DD",17.9001,17.90011,0,"IX","B",17.90011,.01)

"^DD",17.9001,17.90011,0,"NM","TEST ROUTINE")
 
"^DD",17.9001,17.90011,0,"UP")
17.9001
"^DD",17.9001,17.90011,.01,0)
TEST ROUTINE^MF^^0;1^K:$L(X)>8!($L(X)<3) X
"^DD",17.9001,17.90011,.01,1,0)
^.1
"^DD",17.9001,17.90011,.01,1,1,0)
17.90011^B
"^DD",17.9001,17.90011,.01,1,1,1)
S ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.90011,.01,1,1,2)
K ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)
"^DD",17.9001,17.90011,.01,3)
This is a routine to be used for the MUnit Test Group.  Answer must be 3-8 characters in length.
"^DD",17.9001,17.90011,.01,"DT")
3140731
"^DD",17.9001,17.90012,0)
DESCRIPTION FOR GROUP SUB-FIELD^^.01^1
"^DD",17.9001,17.90012,0,"DT")
3140812
"^DD",17.9001,17.90012,0,"NM","DESCRIPTION FOR GROUP")

"^DD",17.9001,17.90012,0,"UP")
17.9001
"^DD",17.9001,17.90012,.01,0)
DESCRIPTION FOR GROUP^W^^0;1^Q
"^DD",17.9001,17.90012,.01,3)
Enter a description for the Unit Test Group
"^DD",17.9001,17.90012,.01,21,0)
^.001^3^3^3140812^^
"^DD",17.9001,17.90012,.01,21,1,0)
This word processing field provides a location for the developer to enter 
"^DD",17.9001,17.90012,.01,21,2,0)
a description of the purpose or function of the M-Unit Test Group, 
"^DD",17.9001,17.90012,.01,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,23,0)
^^3^3^3140812^
"^DD",17.9001,17.90012,.01,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.90012,.01,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.90012,.01,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,"DT")
3140812
"^DIC",17.9001,17.9001,0)
M-UNIT TEST GROUP^17.9001
"^DIC",17.9001,17.9001,0,"GL")
^%ut(17.9001,
"^DIC",17.9001,"B","M-UNIT TEST GROUP",17.9001)

**END**
**END**
