Cache for OpenVMS/ALPHA V7.x^INT^COM Routines for transport^~Format=Cache.S~
%RO on 18 May 2005  11:04 AM
COMARG^INT^1^59847,16427^0
COMARG D INIT,START,EXIT ; SPLIT OUT ARGUMENTS FROM COMMAND SETS Vers. 2.0V ;03:39 PM  19 Jun 1990; RCR
 QUIT
 ; =====================
INIT S ALVL=ALVL+1,LVLEND(ALVL)=0,INDR(ALVL)=0
 QUIT
 ; =====================
 ;
START ; GET THE NEXT TOKEN AND PARSE
 D ^COMTOK
 I TOK=""&(DELIM="(") S SLVL=SLVL+1
 D:TOK'="" TOKARG
 D DLMBLK
 Q:POSTC!LVLEND(ALVL)!CMDEND
 Q:ALVL>0
 S ERRTYP="7B" D ^COMERR
 QUIT
 ; =====================
EXIT ; CLEANUP THE LEVEL FOR THIS CALL TO COMARG
 K LVLEND(ALVL),ENDSTR,INDR(ALVL)
 S ALVL=ALVL-1,ASET=SVSET
 QUIT
 ; =====================
TOKARG I TOK["$" D ^COMFUNC Q
 I CMDARG["L" D ^COMRLAB Q
 I CMD="FOR" D FORTYP Q
 I "SRX"[CMDARG D ^COMSYM Q
 QUIT
 ; =====================
DLMBLK I DELIM="""" D ^COMSTRG
 I DELIM="@" S ERRTYP="6D",DELIM="%",INDR(ALVL)=1 D ^COMERR
 I FUNC'="$SELECT" I DELIM=":"&(CMD'="FOR") D ^COMPOST S APST=1
 S CMDEND=(DELIM=" ")!LINEND!CMDEND
 S LVLEND(ALVL)=(",)"[DELIM)!CMDEND
 S:DELIM="=" EQUFLG=1
 QUIT
 ; =====================
 ; TEST FOR CONTROL COMMAND COUNT AND ORGANIZATION (IE FIRST COMMAND)
 ; TEST FOR SINGLE ARGUMENT SET
 ;
FORTYP S ASET="REF"
 S:ACNT=0 ASET="SET"
 D ^COMSYM
 QUIT
 ; =====================

COMBLK^INT^1^59847,16427^0
COMBLK D START ; PARSES BLOCKS OF CODE FROM A ROUTINE Vers. 2.0V ;11:02 AM  31 Jul 1998; RCR
 QUIT
START ; IDENTIFY A BLOCK BY PARSING EACH LINE UNTIL PROGRAM FLOW STOPS
 S BLKEND=0,CMDONE=0
 F BLKLIN=0:1 D ^COMLINE,LINPARS:'RTNEND Q:BLKEND!RTNEND
 I LLCNT1>20 S ERRTYP="3H2" D ^COMERR S LLCNT1=0 ; RESET TRIGGER
 QUIT
LINPARS ; PARSE A LINE
 F CMDCNT=0:1 D ^COMMAND Q:LINEND
 S CMDONE=CMDONE+(CMDCNT>0)
 I CMDCNT>5 S ERRTYP="4H" D ^COMERR
 QUIT

COMERPT^INT^1^59847,16427^0
COMERPT D START ; ERROR REPORT ON COMPLY PACKAGE PROGRESS Vers. 1.02P ;11:24 AM  5 Dec 1988; RCR
 QUIT
START ; REPORT THE ERRORS COLLECTED
 W:$Y>60 #
 D ^COMTIME
 W !!,?10,"EXCEPTION DISTRIBUTION",!,?10,%T
 W !,?6,"COUNT EXCEPTION DESCRIPTION"
 S A="",RNUM=0
 I '$D(PASS) F LP02=1:1 S A=$O(RERCNT(A)) Q:A=""  D NEWERR
 F LP02=1:1 S A=$O(ERRCNT(A)) Q:A=""  D REPORT
 W:RNUM !!,$J(RNUM,10)," EXCEPTIONS HANDLED "
 I RTN="" W "  ",RTNNUM," ROUTINES PROCESSED"
 K A,RNUM,LP02
 QUIT
NEWERR ; SCAN EACH OF THE ERRORS LOOKING FOR ERROR TYPES AND ACCUMULATE CNT
 S:'$D(ERRCNT(A)) ERRCNT(A)=0
 S ERRCNT(A)=ERRCNT(A)+RERCNT(A)
 QUIT
REPORT ; WRITE THE EXCEPTION OUT TO THE PRINTER
 W !,$J(ERRCNT(A),10)_"  ",?15,A_" ",?20,^COMDEF("ERR",A)
 S RNUM=RNUM+ERRCNT(A)
 QUIT

COMERR^INT^1^59847,16427^0
COMERR ; ERROR REPORT HANDLER Vers. 2.0V ;08:04 AM  31 Mar 1993; RCR
 QUIT:ERRTYP=""
 ; HANDLE AND CLEAR THE ERROR
 N ERRNAM
 S:'$D(RTNLAB) RTNLAB=RTN
 S ^COM("ERR",RTN,TXTNUM,CMDCNT)=ERRTYP_"#"_RTNLAB_":"_LINPNT
 ; S:'$D(RERCNT(ERRTYP)) RERCNT(ERRTYP)=0
 S RERCNT(ERRTYP)=$G(RERCNT(ERRTYP))+1,RNUMER=RNUMER+1
 S:$D(^COMDEF("ERR",ERRTYP,"MSG")) WRN=" "_^COMDEF("ERR",ERRTYP,"MSG")
 S WRN="",ERRNAM=ERRTYP,ERRTYP=""
 I RTN'="" I $D(COMNOPR) Q:$D(^COM("TEXT",RTN,TXTNUM))  Q:'COMNOPR
 U LISDEV
 ;
 I LINPRT W !,SPCR,!,LINE S LINPRT=0
 W !,?LINPNT-2,"^"_RNUMER
 W !,"<** ",ERRNAM,WRN," ",^COMDEF("ERR",ERRNAM)
 W " **> "_$G(LABRTN)_"  "_$G(CMD)
 ; W !,?12,LINPNT,?20,CMD,?30,LLCNT
 QUIT

COMFLIN^INT^1^59847,16427^0
COMFLIN ; FIRST LINE OF ROUTINE PARSING Vers. 2.0V ;04:03 PM  19 Jun 1990
V ; RCR
 ; HANDLE THE SPECIAL PROBLEMS OF THE FIRST LINE
 S MAXL=120
 D ^COMLINE,COMMENT
 S MAXL=80,BLKEND=0
 F CMDCNT=0:1 D ^COMMAND Q:LINEND
 ;
 ; I CMD'="DO"!(CMDCNT>1) S ERRTYP="2A1" D ^COMERR
 ;
 D ^COMLINE,VERSION
 K LP06,T
 QUIT
 ; =============================
COMMENT ; CHECK THE FIRST LINE COMMENTS AND DATES
 D ^COMERR
 I $P(LABEL,"(")'=RTN S ERRTYP="1A" D ^COMERR
 ;
 ; COUNT THE NUMBER OF FIELDS
 ;
 I $L(LINE,";")<4 S ERRTYP="2E" D ^COMERR QUIT
 I $E(LABEL,1,3)'=PKGID&(LABEL'["%") S ERRTYP="1B" D ^COMERR QUIT
 ;
 ; CLEAN-UP THE DATE
 ;
 I $L($P(LINE,";",2))<6 S ERRTYP="2B" D ^COMERR
 S T=$P(LINE,";",3),^COM("COM",RTN)=$P(LINE,";",2,10)
 F LP06=1:1:$L(T) Q:$E(T,LP06)'=" "
 S T=$E(T,LP06,255)
 D DATE
 S T=$P(LINE,";",4)
 F LP06=1:1:$L(T) Q:$E(T,LP06)'=" "
 S T=$E(T,LP06,255)
 F LP06=$L(T):-1:1 Q:$E(T,LP06)'=" "
 S T=$E(T,1,LP06)
 ; I T="" S ERRTYP="2E" D ^COMERR QUIT
 Q:T=""
 I '$D(^COMDEF("PRG",T)) S ERRTYP="2D" D ^COMERR
 QUIT
 ; =============================
DATE ; IF DATE IS CORRECT CONTINUE
 Q:T?1.2N1"-"3A1"-"2.4N.E
 Q:T?.E1.2N1" "3A1" "2.4N.E
 S ERRTYP="2C" D ^COMERR
 QUIT
 ; =============================
VERSION ; EVALIATE THE SECOND LINE, LOOKING FOR A VERSION MARKER
 S TXTNUM=1
 I $E(LINE,1,3)'="V ;" S ERRTYP="2V" D ^COMERR S TXTNUM=TXTNUM-1 Q
 S TOK="V",LABEL=RTN,LINPNT=5
 D ^COMRLAB
 QUIT
 ; =============================

COMFUNC^INT^1^59847,16427^0
COMFUNC D START ; PARSE FUNCTION AND SYTEM VARIABLE SYNTAX Vers. 1.02P ; 26-SEP-85 ; RCR
 QUIT
START S TFUNC=TOK
 S:'$D(^COMDEF("FUN",TOK)) TFUNC=$O(^COMDEF("FUN",TOK))
 S:TOK=$E(TFUNC,1,$L(TOK)) FUNC=TFUNC
 Q:CMDEND!(DELIM'="(")
 I $D(^COMDEF("FUN",TFUNC)) S (TOK,FUNC)=TFUNC D SPLTFUN QUIT
 S ERRTYP="7G" D ^COMERR
 QUIT
SPLTFUN S SFUNC(ALVL)=^COMDEF("FUN",FUNC),FLVL(ALVL)=1
 S ^COM("FUN",FUNC,RTNLAB,LINPNT,ALVL)=""
 D GETFUN
 I DELIM="(" D FLVLCNT
 K SFUNC(ALVL),FLVL(ALVL),FSAV(ALVL)
 QUIT
FLVLCNT F FLV=1:1:$L(SFUNC(ALVL),"\") D GETLVL,^COMARG Q:DELIM=")"!CMDEND
 QUIT
GETFUN S TFUNC=SFUNC(ALVL)
 S ERRTYP=$P(TFUNC,":",2) D:$L(ERRTYP) ^COMERR
 S FSAV(ALVL)=$P(TFUNC,":",3)
 QUIT
GETLVL S FLVL(ALVL)=FLV
 I FLV>$L(FSAV(ALVL),"\") S ERRTYP="7G" D ^COMERR Q
 S:DELIM=":"&(FUNC="$SELECT") DELIM="+"
 S CMDARG=$P(FSAV(ALVL),"\",FLV)
 S FLV=FLVL(ALVL)
 QUIT

COMLAB^INT^1^59847,16427^0
COMLAB ;LOAD NEW LABEL AND CHECK FOR PREVIOUS REFERENCE;11:03 AM  31 Jul 1998
V ; COM ; Vers. 2.0V ;01:34 PM  27 Oct 1988; RCR
 ; CHECK NEW LABEL
 I DELIM'=" " S ERRTYP="7E" D ^COMERR
 Q:TOK=""
 I CMDONE&('BLKEND) D
 . S ERRTYP="3A",^COM("LREFS",RTN,LABEL,TOK)="FT"
 . D ^COMERR
 .QUIT
 S (LLCNT,LLCMC,LLCNT1,BLKEND)=0
 S ^COM("LAB",RTN,TOK,"DEF")=TXTNUM,LABEL=TOK
 I TOK?.N   S ERRTYP="3B"   D ^COMERR
 QUIT

COMLINE^INT^1^59847,16427^0
COMLINE ; GET ONE LINE OF CURRENT ROUTINE TO PARSE;03:06 PM  19 Jun 1990; RCR
V ; COM ; Vers. 2.0V ; RCR\PHS
 ;
 ; START - 1) GETS THE NEXT LINE OF THE ROUTINE BEING ANALYSED
 ;             A) TXT IS THE LINE
 ;             B) LINEND INDICATES THAT THE LAST LINE HAS ALREADY BEEN
 ;                                               READ.
 ;         2) SPLIT LINE INTO LABEL AND BODY FIELDS
 ;
 ; GET THE NEXT LINE
 S CTRLCMD=0,(CCMD,ERRTYP)=""
 S TXTNUM=TXTNUM+1,LLCNT=LLCNT+1,LLCNT1=LLCNT1+1,(LINPNT,LINPRT)=1
 I '$D(^COM("TEXT",RTN,TXTNUM)) S (LINEND,RTNEND)=1,LINE="" QUIT
 S LINE=^(TXTNUM),LINEND=0
 D GETLAB
 I $L(LINE)>MAXL S ERRTYP="3F" D ^COMERR
 QUIT
 ; =========================
GETLAB ; GET THE LABEL IF THERE IS ONE
 D ^COMTOK,^COMLAB
 S RTNLAB=LABEL
 S:LLCNT>0 RTNLAB=LABEL_"+"_LLCNT
 S LABRTN=RTNLAB_"^"_RTN
 S RTNLAB="^"_RTN_":"_RTNLAB
 S LLCMC=$G(LLCMC)+($E($P(LINE," ",2))'=";")
 I LLCMC>20 D ^COMERR S ERRTYP="3H3"
 D ^COMERR
 QUIT
 ; =========================

COMLSTK^INT^1^59847,16427^0
COMLSTK D INIT,START,EXIT ; THREADS FLOW OF EACH ROUTINE LABEL Vers. 2.0V ;03:35 PM  19 Jun 1990; RCR
 QUIT
INIT ; SETUP TO DISPLAY THE LOCAL LABEL STACK
 S P=1,(PR,PG(1))=RTN,LINPRT=0,(CMD,COM)="" K ^COM("LDONE"),MORE
 S MSG=" < RECURSIVE AT THIS LEVEL >"
 S MSG2=" < STRUCTURE PREVIOUSLY DEFINED >"
 S:$D(^COM("COM",PR)) COM="   ;"_$E(^(PR),1,80)
 U LISDEV W !!,?10,"STRUCTURE LISTING FOR ROUTINE ",RTN,!!,"^"_RTN,COM
 QUIT
 ; ======================
START ; BEGINNING OF RECURSIVE STACK CALL TO PRINT REFERENCES
 D NEXTREF
 S NXT="",MORE=0,^COM("LDONE",RTN)=""
 F LP02=1:1 S NXT=$O(^COM("LAB",RTN,NXT)) Q:NXT=""  D PASS2CK
 Q:'MORE
 W !!,?12,"UNREFERENCED LABEL STRUCTURES"
 F LP02=1:1 W ! S NXT=$O(MORE(NXT)) Q:NXT=""  D PASS2
 QUIT
 ; ======================
EXIT ; CLEANUP FROM THE LABEL STACK PRINTING
 K A,BF,I,LP02,LP01,LP03,COM,MORE,MSG,MSG2,NXT,PASS,PG,PR,RT,SCN
 QUIT
 ; ======================
PASS2CK ; BUILD THIS LEVEL'S DESCENDENTS, AVOID ALREADY REPORTED LABELS
 Q:$D(^COM("LDONE",NXT))
 S MORE=1,MORE(NXT)=""
 QUIT
 ; ======================
PASS2 ; REPORT ANY UNREFFERENCED LABELS
 W !,NXT
 S PG(1)=NXT,(P,LINPNT)=1,RTNLAB="^"_RTN_":"_NXT,LABRTN=NXT_"^"_RTN
 S ERRTYP="3I" D ^COMERR,NEXTREF
 QUIT
 ; ======================
NEXTREF ; GO GET THE NEXT REFERENCE
 S SCN=PG(P) K MORE(SCN)
 Q:'$D(^COM("LREFS",RTN,SCN))
 S P=P+1,I(P)=1,(RT,BF(P))=""
 F LP01=1:1 S RT=$O(^COM("LREFS",RTN,SCN,RT)) Q:RT=""  D LOADBF
 F I(P)=1:1:$L(BF(P),",") D GETPR,NEXTREF:PASS
 S P=P-1
 QUIT
 ; ======================
LOADBF ; LOAD THE STACK LEVEL BUFFER WITH LABELS
 S BF(P)=BF(P)_RT
 S:$O(^COM("LREFS",RTN,SCN,RT))'="" BF(P)=BF(P)_","
 QUIT
 ; ======================
GETPR ; GET THE NEXT PROGRAM
 S (PG(P),PR)=$P(BF(P),",",I(P)),A=$P(PR,"^",2),COM=""
 Q:PR=""
 I A'="" S:$D(^COM("COM",A)) COM="   ;"_^(A)
 S LST=P-1 W !
 F M=1:1:P I PG(M)=PG(P) S:M=P M=999 Q
 D STEPR S PASS=1,LST=(P-1)*2
 S:'$D(^COM("LDONE",PR)) ^COM("LDONE",PR)=999
 I P'<^COM("LDONE",PR) S PASS=0 W MSG2 S MSG2=" < PREVIOUS >>>"
 D RECURS:M<999
 Q:'PASS
 S ^COM("LDONE",PR)=P
 QUIT
 ; ======================
STEPR ; STACK LEVEL PRINT WITH CROSS TRACKS
 F LP03=1:1:LST S TMP="! " S:LP03=M TMP="+-" S:LP03>M TMP="--" W TMP
 W PR,COM
 QUIT
 ; ======================
RECURS ; RECURSIVE ERROR FOUND
 U LISDEV W MSG S MSG=" < RECURSIVE ***"
 S PASS=0,LINPNT=((P-1)*2)+2,RTNLAB="^"_RTN_":"_PR,LABRTN=PR_"^"_RTN
 S ERRTYP="3D1" D ^COMERR
 QUIT

COMMAND^INT^1^59847,16427^0
COMMAND D START,EXIT ; COMMAND - VALIDATES COMMANDS AND DRIVES ARGUMENT SCAN Vers. 2.0V ;01:54 PM  27 Oct 1988; RCR
 QUIT
 ;
START ; BEGIN LOOKING FOR THE COMMAND AND IT'S ARGUMENTS
 S (ALVL,EQUFLG,POSTC,OKARG,CMDEND,CPST,APST,TRMCMD)=0,PSTYP=1
 S PCTRL=CTRLCMD,(CMDTYP,FUNC)=""
 K CMDDEF
 F LP02=1:1 D ^COMTOK Q:(TOK'="")!LINEND
 Q:TOK=""
 D COMGET
 QUIT:LINEND
 D ARGINIT,CONTROL:CMDTYP["C"
 F ACNT=0:1 Q:CMDEND!LINEND  D ARGINIT:DELIM=",",^COMARG
 I 'OKARG,(ACNT>1) S ERRTYP="7I" D ^COMERR
 QUIT
EXIT ; CLEANUP THE EXIT FROM THIS ROUTINE
 Q:'$D(CMDTYP)
 D BLKCHK:$D(CMDDEF) ; UNSCHEDULED BLOCK END CHECK
 I 'PCTRL&(CMDTYP["T"&'(CPST!APST)) S (TRMCMD,BLKEND)=1
 S BADTRM=CMDCNT>0&TRMCMD
 I BADTRM S ERRTYP="3H1",BLKEND=1,(CMDCNT,CMDONE)=0 D ^COMERR
 K ACNT,ALVL,BADTRM,CMDDEF,CMDARG,CMDMSK,EQUFLG,FLV,FLVL,FSAV,LVLEND
 K PCTRL,TMPT,TRMCMD
 QUIT
COMGET ; GET THE COMMAND AND PARSE IT
 D VALCMD
 I '$D(CMDDEF) S ERRTYP="7A" D ^COMERR S LINEND=1 Q
 I DELIM=";" S LINEND=1 Q  ; COMMENT HANDLER
 Q:DELIM=" "
 I DELIM=":" S POSTC=1 D ^COMPOST S (CMDEND,POSTC)=0,CPST=1 D DEFCMD
 S ERRTYP=""
 QUIT
ARGINIT ; INITIALIZE THE ARGUMENT
 S APST=0,CMDTYP=CMDHLD,SLVL=1,PSTYP=3,EQUFLG=0,ASET=SVSET
 S CMDARG=$P(CMDDEF,"\",3),FUNC=""
 QUIT
 ;
VALCMD ;  VALCMD - VALIDATES THE COMMAND AS EXTRACTED
 I '$D(^COMDEF("CMD",TOK)) D CMDVRIF Q:$E(TMPT,1,$L(TOK))'=TOK
 S CMD=TOK,CMDDEF=^COMDEF("CMD",TOK)
 D DEFCMD,^COMERR
 QUIT
DEFCMD ; GET THE DEFINITIONS FOR THE COMMANDS
 S (CMDTYP,CMDHLD)=$P(CMDDEF,"\",1),ERRTYP=$P(CMDDEF,"\",4)
 S (SVSET,ASET)=$P(CMDDEF,"\",5)
 S:SVSET="" (SVSET,ASET)="REF"
 S CMDARG=$P(CMDDEF,"\",3),CMDMSK=$P(CMDDEF,"\",2),OKARG=$E(CMDMSK,2)
 QUIT
BLKCHK ; CHECK FOR AN UNEXPECTED BLOCK END
 Q:'BLKEND
 S ERRTYP="7K" D ^COMERR S BLKEND=0,LINEND=1,(CMDCNT,CMDONE)=0
 QUIT
 ;
CMDVRIF ; VERIFY THE COMMAND BY GETTING THE NEXT COMMAND AND COMPARING WITH
 ;   THE TOKEN.  IF IT WAS A SINGLE CHARACTER COMMAND, SET THE TOKEN
 ;   EQUAL TO ITS PROPER COMMAND.
 ;
 I $E(TOK,1)="Z" D ^COMERR S TOK=$E(TOK,2,99)
 S TMPT=$O(^COMDEF("CMD",TOK))
 Q:$E(TMPT,1,$L(TOK))'=TOK
 S TOK=TMPT
 QUIT
CONTROL ; LOOK FOR CONTROL COMMANDS, QUIT, FOR, IF, ELSE
 Q:(CMD="QUIT")&(CCMD["F")
 S CCMD=CCMD_$E(CMD,1),CTRLCMD=$L(CCMD)
 I CTRLCMD>2 S ERRTYP="5B" D ^COMERR
 I CTRLCMD=1&(CMDCNT>0) S ERRTYP="5A" D ^COMERR
 QUIT

COMPKGE^INT^1^59847,16427^0
COMPKGE D START ; PACKAGE PARSER FOR THE COMPLIANCE CHECKER Vers. 2.0V ;09:22 AM  31 Oct 1988; CHRIS RICHARDSON
 QUIT
 ;
 ; START - 1) INITIALIZE COUNTERS
 ;         2) SELECTS EACH ROUTINE IN TURN
 ;
START ; PACKAGE PARSING, ONE ROUTINE AT A TIME
 S PKGEND=0
 S PKGID=$E(RTN,1,3)
 F LP00=0:1 D QUERY,^COMRTN Q:PKGEND
 Q:'PROD
 K APST,ASET,BLKCNT,CCMD,CMDARG,CMD,CMDCNT,CMDDEF,CMDEND,CMDMSK
 K CMDONE,CPST,DELIM,EQUFLG,ERNUM,INKEY,LABEL,LABRTN
 K LINE,LINPNT,LINPRT,LINEND,LLCNT,LLCNT1,LP00,LP01,LST,MAXL
 K PKGEND,POSTC,PSTYP,RTNEND,RTNLAB,SPCR,TMP,TOK,TTOK
 QUIT
QUERY ; LOOK FOR INPUT
 U 0 R *TMP:0
 Q:'$T
 S INKEY=$C(TMP),PASS=1
 F LP01=0:0 R *TMP:0 Q:'$T  S INKEY=$C(TMP)
 D LIST2DO W ! K PASS
 U LISDEV
 QUIT
LIST2DO ; DEMAND REPORT OF STACK OF ROUTINES LEFT TO DO
 S TMP=""
 W #,"CURRENT ROUTINE =",RTN
 W !!,"ROUTINES LEFT TO DO"
 F ERNUM=0:1 S TMP=$O(^COM("NXT",TMP)) Q:TMP=""  W !,?2,TMP
 W:'ERNUM !,"  LAST ROUTINE"
 Q:'NUMER!(INKEY'="E")
 D ^COMERPT W "SO FAR"
 QUIT

COMPLY^INT^1^59847,16427^0
COMPLY ; CHECK FOR COMPLIANCE WITH THE NWC MUMPS PROGRAMMING STANDARDS V	;08:36 AM  31 Mar 1993;05:24 AM  14 Jun 1990 ; RCR
 ;
 ; INIT - 1) SELECTS ROUTINE TO BE CHECKED.
 ;        2) INITIALIZES ROUTINE STORAGE AND ERROR REPORTING AREA.
 ;        3) CONTROLS THE CONTINUED EXECUTION OF THE MODEL.
 ;
 ; INITIALIZE AND SETUP FOR THE RUN
 W !,?10,"MUMPS Code Compliance Checker. Version 2.0",!!
 D ^%ZIS
 Q:'$D(IOS)
 Q:$G(POP)
 I '$D(LISDEV) S LISDEV=30 S:$L(IO) LISDEV=IO
 I IOS'=$G(LISDEV) O LISDEV
 ; O LISDEV ; :NEW:0 ; VAX DSM
 D INIT1
 Q:'$D(^COM("NXT"))  ; NO ROUTINES SELECTED
 F  D XCLUD   Q:'$D(X)
 F  D STKDPT  Q:'$D(X)
 F  D NOPRNT  Q:'$D(X)
 S RTN=$O(^COM("NXT","")),FRSTRTN=RTN
 U LISDEV
 D START
 QUIT
 ;
 ; START - 1) STORES THE ROUTINES IN ^COM("TEXT",RTN) GLOBAL
 ;         2) CONTROLS ERROR SCANNING AND PARSING
 ;
INIT1 ; CONTINUATION BLOCK
 N I
 S I=""
 F  S I=$O(^COM(I)) Q:I=""   K ^COM(I)
 S (CMDCNT,CMDONE,LLCNT,LLCNT1,RNUMER,NUMER,RTNEND,RTNNUM)=0
 S CMD="",PROD=1,BLKEND=1,SPCR=""
 F LP=1:1:35 S SPCR=SPCR_" -"
 W !,"Enter Package Entry Routine Name to be checked."
 D ^COMRSEL
 QUIT
 ; ==========================================
START ; BEGIN THE PROCESS OF PARSING THE ROUTINE PACKAGE
 D ^COMTIME
 W !,"BEGIN LOADING >",RTN,!,?2,%T,!
 S COMCSTK=1
 D ^COMSTORE
 W !,"Routine stored, begin analysis"
 ; START ANALYZING CODE FROM ^COM("TEXT")
 D ^COMPKGE,EXIT
 QUIT
 ;
 ; EXIT - 1) GENERATES PACKAGE STRUCTURE LISTING
 ;        2) REPORTS NUMBER AND TYPES OF ERRORS
 ;        3) CLEANS UP (UPDATE CONFIGURATION FILE) (TBD)
 ;
 ; ==========================================
EXIT ; COMPLETE AND CLEAN-UP THE RUN
 D ^COMSTK
 K ERRTYP
 S RTN=""
 D ^COMERPT
 U LISDEV W !
 Q:'PROD
 C LISDEV ; :SPOOL ; VAX DSM
 K %T,ABRT,ALVL,BLKEND,C,ERRCNT,FRSTRTN
 K LINPRT,NUMER,PKGID,PROD,RERCNT,RNUMER,RTN,RTNEND,RTNLAB,RTNNUM
 K TXTNUM,WRN
 ; U 0
 QUIT
 ; ==========================================
XCLUD ; EXCLUDE CERTAIN ROUTINES FROM THE ANALYSIS
 N T
 R !,"ENTER THE NAME OF A ROUTINE EXCLUDE FROM PROCESSING >",X
 I X["*" D    Q
 . S (T,X)=$TR(X,"*")
 . S ^COM("DONE",X)="EXCLUDED"
 . F  S X=$O(^ (X))  Q:X'[T  S ^COM("DONE",X)="EXCLUDED"
 .QUIT
 I X'="" S ^COM("DONE",X)="EXCLUDED" Q
 ;
 K X
 QUIT
 ; ==========================================
NOPRNT ; EXCLUDE CERTAIN ROUTINES FROM THE ANALYSIS
 N X
 K COMNOPR
 R !,"PRINT ALL ERRORS? <Y>*:",*X
 S:X>97 X=X-32
 S X=$C(X)
 I X="N"  S COMNOPR=1
 Q:'$D(COMNOPR)
 ;
 R !,"PRINT ONLY ROUTINE STRUCTURE ERRORS? <Y>*:",*X
 S:X>97 X=X-32
 S X=$C(X)
 I X="N" S COMNOPR=0
 QUIT
 ; ==========================================
STKDPT ; SET STACK DEPTH FOR ANALYSIS
 NEW X
 S COMXDPT=999
 F  D STKASK   Q:X>0  W:$X>50 ! W ?45," [ENTER A NUMBER PLEASE]"
 QUIT
 ; ==========================================
STKASK ; REQUEST INPUT FOR THE STACK DEPTH
 R !,"ENTER THE STACK DEPTH TO STOP AT >",X
 S X=+X
 S:X>0 COMXDPT=X
 QUIT

COMPOST^INT^1^59847,16427^0
COMPOST D START,EXIT ; POSTCONDITIONAL HANDLER Vers. 2.0V ;02:03 PM  27 Oct 1988; RCR
 QUIT
 ;
START ; BEGIN POST CONDITIONAL PROCESSING
 S:'$D(SLVL) SLVL=0
 S CMDTYP="S",CMDARG="X",PSTEND=0
 S POSTC=1,(SVSET,ASET)="REF"
 ;
 ; TEST FOR COMMAND OR ARGUMENT POST-COND LEGALITY
 ;
 I CMD'="FOR"&($E(CMDMSK,PSTYP)=0) S ERRTYP="7H" D ^COMERR
 ;
 ; COMMAND OR ARGUMENT SCANNING
 ;
 F LP05=1:1 D ^COMARG,POSTEND Q:PSTEND
 S CMDEND=LINEND!DELIM=" "
 Q:CMD="FOR"!CMDEND!(", "[DELIM)
 S ERRTYP="7C" D ^COMERR
 QUIT
EXIT ; CLEANUP THE POST-CONDITIONAL PROCESSING
 S POSTC=0
 K PSTEND,LP05
 QUIT
POSTEND ; LOOK FOR THE END OF THE POST-CONDITIONAL, " " OR ","
 S PSTEND=LINEND!(DELIM=" ")
 S:PSTYP=3 PSTEND=PSTEND!(DELIM=","&(ALVL=1))
 QUIT

COMRLAB^INT^1^59847,16427^0
COMRLAB ; LABEL REFERENCE ROUTINE ;03:43 PM  19 Jun 1990
V ;COMPLY Vers. 2.0V ; RCR
 ; SETUP FOR THE PARSING OF THE ROUTINE LABEL
 I DELIM="@" D SYMSRC QUIT
 I TOK["^" D RTNREF
 I DELIM="+" D LABSPLT
 Q:TOK=""
 S ^COM("LAB",TOK,RTNLAB,LINPNT,"REF")=""
 S:LABEL'="" ^COM("LREFS",RTN,LABEL,TOK)=""
 I $D(^COM("LAB",RTN,TOK,"DEF")) S ERRTYP="3E" D ^COMERR
 QUIT
 ; =================
SYMSRC ; GO LOOKING FOR A LABEL REFERENCE
 S TCM=CMDARG,CMDARG="S"
 D ^COMARG
 S CMDARG=TCM K TCM
 QUIT
 ; =================
LABSPLT ; ALTERNATE ENTRY POINT
 S ERRTYP="3C2" D ^COMERR
 S TTOK=TOK
 D ^COMTOK
 I TOK["^" D RTNREF
 S TOK=$P(TTOK,"+",1)
 QUIT
 ; =================
RTNREF ; ROUTINE REFERENCE
 S NXTRTN=$P(TOK,"^",2)
 S:LABEL'="" ^COM("LREFS",RTN,LABEL,TOK)=""
 I $L($P(TOK,"^",1)) S ERRTYP="3C1" D ^COMERR
 I NXTRTN="" K NXTRTN Q
 S ^COM("NXT",NXTRTN)=COMCSTK+1
 S ^COM("REFS",RTN,NXTRTN)=""
 K NXTRTN
 QUIT
 ; =================

COMRPRT^INT^1^59847,16427^0
COMRPRT D START ; ERROR REPORT ON LAST ROUTINE Vers. 2.0V ;11:29 AM  31 Oct 1988; RCR
 QUIT
START ; COLLECT THE ERRORS ACCUMULATED OVER THE RUN
 Q:'$D(RERCNT)  ; IF NO ERRORS, QUIT
 W:($Y#66)>50 #
 D ^COMTIME
 W !!,?10,"ERROR DISTRIBUTION FOR ",RTN
 W !,?10,%T,!,?6,"COUNT  ERROR  DESCRIPTION"
 S A=""
 F LP02=1:1 S A=$O(RERCNT(A)) Q:A=""  D REPORT
 W:RNUMER !!,$J(RNUMER,10)," ERRORS HANDLED FOR THIS ROUTINE"
 S NUMER=NUMER+RNUMER,RNUMER=0
 K A,RERCNT,RNUM,LP02
 QUIT
REPORT ; OUTPUT THE STATEMENT OF THE ERROR
 S RNUM=RERCNT(A)
 W !,$E($J(RNUM,10),1,13)_"  "_$E(A_"      ",1,5)_^COMDEF("ERR",A)
 S:'$D(ERRCNT(A)) ERRCNT(A)=0
 S ERRCNT(A)=ERRCNT(A)+RNUM
 QUIT

COMRSEL^INT^1^59847,16427^0
COMRSEL D START,EXIT ; ROUTINE NAME ENTRY AND LOADING Vers. 2.0V ;02:09 PM  27 Oct 1988; RCR
 QUIT
START ; PROMPT FOR THE ROUTINE NAME
 NEW LP05,LOADTST
 S (AB,OK)=0
 F LP05=1:1 D PROMPT Q:OK!AB  W !,"ENTRY IN ERROR, TRY AGAIN"
 QUIT
EXIT K AB,OK
 S $ZE=""
 QUIT
PROMPT R !,"Package Entry Point> ",RTN
 I RTN="" S AB=1 Q
 S OK=(RTN?1"%".AN)!(RTN?1A.AN)
 Q:'OK
 S OK=0
 ; OSEHRA Modification: Made by J.Snyder <snyderj@osehra.org>
 ; ORIGINAL LINE
 ; S LOADTST="S $ZTRAP=""ERRTRAP^COMRSEL"" ZL "_RTN_" ZL COMRSEL S OK=1"
 S LOADTST="S $ZTRAP=""ERRTRAP^COMRSEL"""
 I +$SY=0 S LOADTST=LOADTST_" ZL "_RTN_" ZL COMRSEL "
 I +$SY=47 S LOADTST=LOADTST_" ZL """_RTN_""" "
 S LOADTST=LOADTST_"S OK=1"
 ;END OSEHRA Modification: Made by J.Snyder <snyderj@osehra.org> 
 X LOADTST
 I OK S ^COM("NXT",RTN)=1 K ^COM("DONE",RTN)
 QUIT
ERRTRAP ;  Test to see if the routine is there, Perform this if not.
 U 0 W !,$ZERR
 QUIT

COMRTN^INT^1^59847,16427^0
COMRTN D START,EXIT ; LOAD AND PARSE A ROUTINE Vers. 2.0V ;11:00 AM  31 Jul 1998; RCR
 QUIT
START ; CHECK FOR ABORT AND THEN DO ROUTINE PARSING
 D PRSRTN:'ABRT,^COMLSTK
 S (ABRT,RTNEND)=0
 D ^COMRPRT
 F LP01=1:1 S RTN=$O(^COM("NXT","")) D CLRTN Q:RTNSRC
 I RTN="" S PKGEND=1 Q
 W #,"Begin Routine <",RTN,"> Analysis"
 S X="ERRTRAP^COMRTN"
 S @^%ZOSF("TRAP")
 D:$D(^COM("DONE",RTN)) ^COMSTORE
 U LISDEV
 S $ZE="" ; $ZT=$ZTRAP DSM
 QUIT
EXIT ; CLEANUP AFTER THE PROCESSING OF A ROUTINE
 K BLKCNT,BLKLIN,CMDHLD,CMDTYP,CTRLCMD,FUNC,OKARG
 K SLVL,SVSET,TFUNC,RTNSRC
 Q:ABRT
 S ERRTYP="",BLKEND=1,LABEL=RTN
 QUIT
 ;
 ; PARSE - 1) SETS UP SCRATCH COUNTERS
 ;         2) CONTROLS BLOCK1 PARSING
 ;         3) CONTROLS SCAN OF THE REST OF THE ROUTINE
 ;         4) SAVE ERROR TOTALS, (IF ANY)
 ;
CLRTN ; CLEAR THE ROUTINE
 I RTN="" S RTNSRC=1 Q
 S COMCSTK=^COM("NXT",RTN)
 S RTNSRC='$D(^COM("DONE",RTN))&(COMCSTK'>COMXDPT)
 I COMCSTK'>COMXDPT S ^COM("DONE",RTN)=COMCSTK
 K ^COM("NXT",RTN)
 QUIT
PRSRTN ; DO THE PROCESSING OF THE ROUTINE
 S:'$D(RTNNUM) RTNNUM=0 S RTNNUM=RTNNUM+1
 D ^COMFLIN
 I RTN'=LABEL S ERRTYP="1A" D ^COMERR
 F BLKCNT=0:1    D ^COMBLK  Q:RTNEND
 I BLKCNT>20 S ERRTYP="3H4" D ^COMERR
 QUIT
ERRTRAP ; FAIL TO LOAD ROUTINE, GENERATE A MESSAGE AND CONTINUE
 S ABRT=1,LABEL=RTN,RTNLAB=LABEL_"^"_RTN
 S ERRTYP="7J" D ^COMERR
 S ^COM("DONE",RTN)="7J"
 QUIT

COMSTK^INT^1^59847,16427^0
COMSTK D INIT,START,EXIT ; THREADS FLOW OF COMPLY ROUTINES;06:33 AM  10 Jul 1990
V ; COMPLY ; VERSION 2.0V ;06:26 AM  10 Jul 1990 ; RCR
 QUIT
 ; ======================================
INIT ; SETUP FOR THE PRINTING OF THE CALLING TREE
 S P=1,(CMD,PG(1))=FRSTRTN,(TXTNUM,LINPRT)=0,RT=""
 F LP00=1:1 S RT=$O(^COM("DONE",RT)) Q:RT=""  S ^COM("DONE",RT)=999
 S MSG=" < RECURSIVE AT THIS LEVEL >"
 S MSG2=" < STRUCTURE PREVIOUSLY DEFINED >"
 U LISDEV W #,?10,"STRUCTURE LISTING FOR ",FRSTRTN,!!,FRSTRTN
 QUIT
 ; ======================================
START ; BEGIN THE EVALUATION OF THE ROUTINES IN SEQUENCE BY DEPTH, RECURSIVE
 S SCN=PG(P)
 Q:'$D(^COM("REFS",SCN))
 S P=P+1,I(P)=1
 S RT="",BF(P)=""
 F LP00=1:1 S RT=$O(^COM("REFS",SCN,RT)) Q:RT=""  D LOADBF
 F I(P)=1:1:$L(BF(P),",") D NEXTRTN,START:PASS
 S P=P-1
 QUIT
 ; ======================================
EXIT ; CLEANUP ON EXIT
 Q:'PROD
 K BF,CMD,CMDCNT,I,LABRTN,LINPNT,LP00,LP01,M,MSG,MSG2,P,PASS,PG,PR,RT
 K SCN,TXTNUM
 QUIT
 ; ======================================
LOADBF ; LOAD THE BUFFER FOR THIS ROUTINE
 S BF(P)=BF(P)_RT
 S:$O(^COM("REFS",SCN,RT))'="" BF(P)=BF(P)_","
 QUIT
 ; ======================================
NEXTRTN ; GO GET THE NEXT ROUTINE
 S (PG(P),PR)=$P(BF(P),",",I(P))
 S COM=""
 S:$D(^COM("COM",PR)) COM="   ;"_$E(^(PR),1,80)
 S BU=$J("",(P-1)*2)_" <"_P_"> "_PR
 ; W !,$J("",(P-1)*2)_" <"_P_"> "_PR_COM
 S PASS=1
 S:'$D(^COM("DONE",PR)) ^COM("DONE",PR)=999
 I P'<^COM("DONE",PR) S PASS=0 S COM=MSG2 S MSG2=" < PREVIOUS >>> "
 ; I P'<^COM("DONE",PR) S PASS=0 W MSG2 S MSG2=" < PREVIOUS >>> "
 F LP01=1:1:P-1 I PG(LP01)=PG(P) D RECURS Q
 I $D(BU) D OUTPUT
 Q:'PASS
 S ^COM("DONE",PR)=P
 QUIT
 ; ======================================
RECURS ; A RECURSION HAS BEEN FOUND, NOW REPORT IT
 S PASS=0,CMD=PR,CMDCNT=P,TXTNUM=TXTNUM+1
 U LISDEV S COM=COM_MSG S MSG=" < RECURSIVE ***"
 S LINPNT=(P*2)+2,(LABRTN,RTNLAB,RTN)=PR_" <"_LP01_"> "
 D OUTPUT
 S ERRTYP="3D2" D ^COMERR
 QUIT
 ; ======================================
OUTPUT ; PRINT THE OUTPUT BUFFER, BU, THEN KILL IT.
 W !,$E(BU_COM,1,80)
 K BU
 QUIT
 ; ======================================

COMSTORE^INT^1^59847,16427^0
COMSTORE D INIT,START,EXIT ; LOAD ROUTINE NAMES INTO ^COM("TEXT") Vers. 2.0V ;02:12 PM  27 Oct 1988; CHRIS RICHARDSON
 QUIT
 ;
 ; INIT - BUILDS SYMBOL TABLE CONTROL STRUCTURES AND START EXECUTES THEM.
 ;     CNTRL - EXECUTION CONTROL
 ;      LOAD - LOADS THE ACTUAL ROUTINE INTO THE ROUTINE BUFFER
 ;       RTN - ROUTINE NAME TRAVELER
 ;      SAVE - SAVES EACH LINE FROM THE ROUTINE BUFFER AS ^COM("TEXT")
 ;      TRTN - TEXT ROUTINE TRANSFER
 ;
INIT ; PREPARE FOR THE LOAD ATTEMPT
 S (LLCNT,TXTNUM)=0,ABRT=1
 ; Q:$D(^COM("DONE",RTN))
 ; OSEHRA Modification: Made by J.Snyder <snyderj@osehra.org>
 ; ORIGINAL LINES
 ; S CNTRL=" ZL COMSTORE S ABRT=0"
 ; S CNTRL="ZL "_RTN_" X SAVE"_CNTRL
 ; S SAVE="F J=1:1 S TXT=TRTN_J_"")"" X TXT I ^(J)="""" K ^(J) Q"
 S CNTRL=" S ABRT=0"
 I +$SY=0 S CNTRL="ZL "_RTN_" X SAVE"_CNTRL
 I +$SY=47 S CNTRL="ZL """_RTN_""" X SAVE"_CNTRL
 S SAVE="F J=1:1 S TXT=TRTN_J_""^""_RTN_"")"" W TXT X TXT I ^(J)="""" K ^(J) Q"
 ;end OSEHRA Modification
 S TRTN="S ^COM(""TEXT"",RTN,J)=$T(+"
 QUIT
START ; ATTEMPT TO LOAD THE ROUTINE
 K ^COM("TEXT")
 ; Q:(COMCSTK>COMSTD)
 ; Q:$D(^COM("DONE",RTN))
 X CNTRL
 S RTNNUM=RTNNUM+1
 QUIT
EXIT ; CLEANUP FROM THE RUN
 K CNTRL,J,LOAD,SAVE,TRTN,TXT
 K ^COM("NXT",RTN) S ^COM("DONE",RTN)=COMCSTK
 QUIT

COMSTRG^INT^1^59847,16427^0
COMSTRG D START,EXIT ; STRING HANDLER Vers. 2.0V ;02:14 PM  27 Oct 1988; RCR
 QUIT
START ; FINDING ONE QUOTE, FIND ANOTHER
 S ENDSTR=($E(LINE,LINPNT)="""")
 I ENDSTR S LINPNT=LINPNT+1 QUIT
 S TLNP=LINPNT
 F STRCNT=1:1 D STRPRS Q:ENDSTR
 S:LINPNT<1 LINPNT=TLNP
 K TLNP
 QUIT
EXIT ; CLEANUP
 K STRCNT
 S:DELIM="""" DELIM="."
 QUIT
STRPRS ; STRING PARSE, MOVE THE LINPNT TO STEP OVER THE STRING.
 S TLNP=LINPNT,LINPNT=$F(LINE,"""",LINPNT)
 S ENDSTR=(($E(LINE,LINPNT)'="""")&(STRCNT#2))!(LINPNT<1)
 I LINPNT<1 S ERRTYP="7F" D ^COMERR
 QUIT

COMSYM^INT^1^59847,16427^0
COMSYM D START ; PARSE STORAGE REFERENCES (GLOBALS AND LOCALS) Vers. 2.0V ;02:19 PM  27 Oct 1988; RCR
 QUIT
START ; DEPENDING ON THE DELIMITOR, SAVE THE TOKEN
 S:DELIM=" " (LVLEND(ALVL),CMDEND)=1
 S:DELIM="," LVLEND(ALVL)=1
 I CMD="FOR"!(CMD="SET")!(CMD="READ") S:(ALVL=SLVL) ASET="SET"
 S:EQUFLG ASET="REF"
 I CMD="KILL" S:ALVL=1 ASET="KIL"
 S CMDEND=CMDEND!LINEND
 I TOK="" D RECURS QUIT
 S ^COM("SYM",TOK,RTN,TXTNUM,LINPNT,ASET)=CMD
 I ASET="SET"&(TOK["%"&(RTN'["%")) S ERRTYP="1C1" D ^COMERR
 I TOK?1A.AN&(RTN["%") S ERRTYP="1C2" D ^COMERR
 D RECURS
 QUIT
RECURS ; GO UPSTREAM TO GET THE NEXT ARGUMENT THAT IS SUBORDINATE TO THE
 ;  CURRENT SYMBOL
 ;
 D ^COMSTRG:DELIM=""""
 Q:CMDEND
 D ^COMARG:DELIM="("
 QUIT

COMTIME^INT^1^59847,16427^0
COMTIME D START ; TIME AND DATE RETURNED IN %T Vers. 2.0V ;01:10 PM  27 Oct 1988; RCR
 QUIT
START ; Pickup local time in printable format
 N (%T)
 D NOW^%DTC
 S (T,T1)=$P(%,".",2),T2="AM" S %T=(($E(X,4,5)-1)*3)+1
 S %T=$E("JanFebMarAprMayJunJulAugSepOctNovDec",%T,%T+2)
 S:T1>1300 T=T-1200 S:T1>1200 T2="PM"
 S T="0000"_T S T=$E(T,$L(T)-3,9) S T=$E(T,1,2)_":"_$E(T,3,4)_" "_T2
 S:$E(T)="0" T=$E(T,2,99)
 S %T=T_" "_%T_" "_(+$E(X,6,7))_", "_(1700+$E(X,1,3))
 QUIT

COMTOK^INT^1^59847,16427^0
COMTOK ; GET NEXT TOKEN AND DELIMINATOR Vers. 2.0V ;11:24 AM  31 Jul 1998; RCR
 ; QUIT
 ; PICK UP THE NEXT TOKEN FROM THE INPUT STRING, MOVE THE LINE POINTER
 S (TOK,DELIM)=""
 F I=LINPNT:1   D GETCHR   Q:DELIM'=""!LINEND   S TOK=TOK_C
 S LINPNT=I+1
 ; W !,TOK,?10,DELIM,!,$E(LINE,LINPNT,255)
 QUIT
GETCHR ; GET THE NEXT CHARACTER AND LOOK FOR A DELIMITOR
 S C=$E(LINE,I)
 S:C'?1AN&("%^$."'[C) DELIM=C
 S:C="" DELIM=" ",LINEND=1
 S:C=";" LINEND=1
 QUIT
