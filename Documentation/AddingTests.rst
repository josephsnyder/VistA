Adding to the OSEHRA Testing Harness
====================================

.. role:: usertype
    :class: usertype

The OSEHRA testing harness contains a series of tests which attempt to cover
as much of the VistA functionality as possible through a few types of
interaction methods.  The current tests fall under one of six categories:

* XINDEX
* MUnit
* RAS functional
* GUI tests ( via Sikuli)
* PyUnitTests
* Other

This document will walk through the process of adding to each facet of the
testing environment.


XINDEX
------

The XINDEX tests are not controlled by the contents of a folder in the
source tree, but are instead determined by the contents of the
``Packages.csv`` file.  During a ``Configure`` step, CMake will read the
``Packages.csv`` file and pull the package name from the second column of data
when it is found.  It will also pull in the routine prefixes to test from the
lines following the package name.

To add an XINDEX test for a newly created package, create a new entry
in the ``Packages.csv`` file with the following information:::

  Package Name,Directory Name,Prefixes,File Numbers,File Names,Globals,VDL_ID

There may a need to create multiple lines in the CSV file.  This happens if
there is more than one prefix for the new package, or a subset of the routines
encompassed by a prefix needs to be excluded.  The package names are only
required on the first line of information, it is left off of all others.

To denote a routine prefix is to be excluded, include a ``!`` before the prefix
in the line.

For Example, a ``New Package`` with the prefix ``NPK`` but not ``NPKG`` would
be entered into ``Packages.csv`` by adding the following lines:

.. parsed-literal::

  NEW PACKAGE,New Package,NPK,,,,
  ,,!NPKG,,,,



XINDEX Exceptions
^^^^^^^^^^^^^^^^^

Adding an exception for an error in the XINDEX results is another potential
update to the OSEHRA testing harness.

Exceptions are granted when an error is reported by XINDEX, but the error is
deemed acceptable and should not cause the test to fail.  Examples of this
include an error reported about a call to a 'missing' routine.  If the routine
checks to see if the routine exists prior to the call, the error can be granted
an exception.

If an exception is needed for a new package, we add an ``XINDEXException``
folder within the package directory.  Within this directory, there should be a
set of files. See below for an example folder with exceptions for the
fictional package ``New Package`` which has an error in the ``NPKRTN`` routine:

.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
                \\
                 \\--- Cache.NPKRTN
                  \\--- GTM.NPKRTN

Each exception file name should follow the naming structure shown above:

``GTM`` or ``Cache`` for the platform the error is reported on,
followed by a period, followed by the name of the routine.

Within these files, each error message with its location offset, if a specific
location is available.  Each error should be placed on a new line within the
file.  An example of the ``NPKRTN`` exceptions can be found below:

.. parsed-literal::

  EN+2        F - Reference to routine '^NPKRTN2'. That isn't in this UCI.
  EN+7        F - Block structure mismatch.

M-UNIT
------

The MUNit tests are also generated by CMake due to the folder structure of a
package. To generate an MUNit test, CMake searches for a ``Testing/MUnit``
directory within each package directory and, if found,  creates the necessary
files to import routines and run them based upon the content of that directory.

For Example, to generate MUnit tests in the ``New Package`` folder, generate a
``Testing/MUnit`` directory within ``Packages/New Package/`` and populate it
with the testing routines and a ``TestList`` file:


.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
           \\--- Testing/
                 \\
                  \\--- MUnit/
                        \\--- TestList
                         \\--- ZZUT1.m
                          \\--- ZZUT2.m

Each ``Testing/MUnit`` directory contains all source (.m) files necessary to
execute the contained tests. These files will be imported before the test is
run. The other file in the directory is the ``TestList`` file.  The
``TestList`` file is text only and contains the commands that will be
executed by the M[UMPS] command line to run each routine.

For Example, the above directory will have the following command lines in
the ``TestList`` file:

.. parsed-literal::

  D ^ZZUT1
  D EN^ZZUT2

To add to an already existing MUnit suite, add the test routines to the MUnit
directory and add the necessary command[s] to execute them to the ``TestList``
file in that directory.


Roll-and-Scroll
---------------

The Roll-and-Scroll (RAS) tests are used to test what a user sitting at the
keyboard of a terminal would interact with.  We accomplish this by connecting
to VistA and using a call-and-response setup to read and answer prompts.

Like the MUnit tests, the RAS tests are also automatically generated by finding
certain content within each package's folder.  In this case, CMake is looking
for a file with ``_test.py`` as the end of its name. When CMake finds such a
file, it will configure a set of scripts which are used to run each test.

The files that are currently in the respository have some caveats which
is recommended to follow to maintain consistency among the tests:

* Each test file ``*_test.py`` will be provided certain information as default
  arguments using the following command line flags:

  [-l LOGGING_LEVEL]
    How much information should be logged, set to be "INFO"
  [-n NAMESPACE]
    String of Cache namespace, if available, from VISTA_CACHE_NAMESPACE CMake variable
  [-c COVERAGE_TYPE]
    ON/OFF value to output human-readable coverage, from TEST_VISTA_COVERAGE_READABLE
  [-cs COVERAGE_SUBSET]
    Name of routines to calculate coverage over, from TEST_VISTA_COVERAGE_SUBSET
  resultdir
    Directory to store log and result files, from TEST_VISTA_OUTPUT_DIR


* Each test will be run from the top level ``Testing`` directory of VistA
  source tree.


The content of each current RAS test files are as follows:

* TestName_suite.py : Contains the Python functions that perform each test

* TestName_test.py : Contains a single Python ``main`` function which calls all other tests.

* TestName.cfg : Contains configuration information about remote connections, if applicable.

For examples of each file, see the `Registration`_, `Scheduling`_, or
`Problem List`_ packages.

A properly populated folder would look like the structure below:

.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
           \\--- Testing/
                 \\
                  \\--- MUnit/
                   \\
                    \\--- RAS/
                          \\
                           \\--- TestName_suite.py
                            \\--- TestName_test.py
                             \\--- TestName.cfg


Sikuli
------

OSEHRA also has developed a test for two of the most used GUIs around the VistA
EHR: CPRS and Vitals.  The test uses a program called Sikuli_ to follow a script
with screenshots of items to interact with.

To add a new Sikuli based test program, the necessary files are not placed into
the VistA directory, but are not placed in a package's directory, they are
placed into the ``Testing/Functional/Sikuli`` directory.

Each entry into this folder should be a ``.sikuli`` folder which contains
two Sikuli scripts (One HTML, the other Python) and all of the images that are
needed in the script.  These two script files will require modification before
the test is able to be run from CMake.

Modification to Sikuli Files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The two script files will need to be configured prior to the test running.
Through the ``configure_file`` command, CMake has the ability to generate a
new file with the content of a specified file while replacing marked CMake
variables with their value in the CMakeCache file.  This is typically denoted
in the file name by having the ``.in`` extension on a file that is going to
be configured before being used.

This configuration is used in these test files to supply information about the
local system to the test. We look to configure two bits of information:

* Sikuli command with path to the original test folder: **required**

* Local information: paths to tested executables, port, or host name values:
  **if necessary**

Since the files with the variables replaced are created in the build directory,
A Sikuli command is used in each of the files to tell Sikuli where the image
files for the script are found, ``addImagePath``:

Add the following line to the ``.py.in`` file before the first image match is
called:::

  addImagePath("${sikuli}")

Add the following line to the ``.html.in`` in the same location as in the
python script:::

  addImagePath(<span class="str">"${sikuli}"</span>)

The string ``${sikuli}`` will be replaced with the full path to the original
.sikuli folder.

This ``${ }`` notation is needed for any CMake variables in the
script which need to be replaced.  Another example from the current Sikuli test
which shows other local information being entered is found in the call to open
the Vitals Manager executable below:::

  openApp(r'${VITALS_MANAGER_EXECUTABLE} /port=${VISTA_TCP_PORT} /server=${VISTA_TCP_HOST} /ccow=disable')

During Configuration, CMake will replace VITALS_MANAGER_EXECUTABLE,
VISTA_TCP_PORT, and VISTA_TCP_HOST variables with their corresponding
value, leading to this line in the new file:::

  openApp(r'C:/Program Files (x86)/Vista/Vitals/VitalsManager.exe /port=9210 /server=127.0.0.1 /ccow=disable')

Each executable will likely need a CMake variable to open if the icon cannot be
found on the screen during the test.  An example of adding a variable for
executables is below and can also be found in the
``Testing/Functional/CMakeLists.txt`` file: ::

  find_program(CPRS_EXECUTABLE CPRSChart.exe DOC "Path to the CPRSChart.exe file")

PyUnitTests
--------------

As more of a general test framework,  `Python Unit Tests`_ have
been generated to test a variety of aspects of the VistA repository.  Some are
used to test the harness itself, while others are used to perform some external
checks to the VistA environment:

* A test for the VistATestClient

* A test for the M2M broker utility of the VistA EHR

* A test for the Patch order generator of the auto-patching utility

The tests are generated by capturing all Python (``.py``)  files within the
``Scripts/Testing/PyUnit`` directory that have ``Test`` as the first word of
the file name.

These files are not configured, so all necessary variables should be passed as
arguments to the file.  See the ``Testing/CMakeLists.txt`` file for an example
of passing arguments to these tests.

Other Tests
-----------

For tests that don't seem to fit into any of the above categories, OSEHRA has
a separate CMakeLists.txt file in the ``../Testing/UserTest/`` directory  where
tests of any type can be added.  The tests here should be added using the
`add_test`_ CMake command. A quick example for adding a test using a file
named ``TestFile.cmake`` and executing it with the CMake executable would look
like this:

.. parsed-literal::

  add_test(UsrTest1 "${CMAKE_COMMAND}" "${CMAKE_CURRENT_SOURCE_DIR}/TestFile.cmake")

Once the test has been added to the CMakeLists.txt file, you will need to
configure the build environment with the ``TEST_VISTA_USERTEST`` option in
order to run the test from the command line.

.. _`Registration`: ../Packages/Registration/Testing/RAS/
.. _`Scheduling`: ../Packages/Scheduling/Testing/RAS/
.. _`Problem List`: ../Packages/Problem%20List/Testing/RAS/
.. _`Python Unit Tests`: http://pyunit.sourceforge.net/pyunit.html
.. _`add_test`: http://www.cmake.org/cmake/help/v2.8.12/cmake.html#command:add_test
.. _Sikuli: http://www.sikuli.org/
